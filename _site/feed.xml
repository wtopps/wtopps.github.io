<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-07-07T12:35:53+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">wtopps</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>GitHub User</name></author><entry><title type="html">关于Kafka分层存储你应该知道的事情</title><link href="http://localhost:4000/kafka/2025/07/07/%E5%85%B3%E4%BA%8EKafka%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85.html" rel="alternate" type="text/html" title="关于Kafka分层存储你应该知道的事情" /><published>2025-07-07T00:00:00+08:00</published><updated>2025-07-07T00:00:00+08:00</updated><id>http://localhost:4000/kafka/2025/07/07/%E5%85%B3%E4%BA%8EKafka%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85</id><content type="html" xml:base="http://localhost:4000/kafka/2025/07/07/%E5%85%B3%E4%BA%8EKafka%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85.html"><![CDATA[<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/Kafka%20Head%20Pic.jpeg?raw=true" alt="banner" /></p>

<h2 id="overview">Overview</h2>

<p>分层存储是 Apache Kafka 3.6.0 提供的一项新的功能，它支持独立扩展计算和存储资源，提供更好的客户端隔离，并允许更快地维护 Kafka 集群。让我们深入了解这项新功能的动机、设计和实施细节。在这篇文章中，我们将重点介绍分层存储的实现，因此我们假定你已经很好地理解了 Kafka 的架构和主要组件。</p>

<h2 id="tiering">Tiering</h2>

<p>分层的概念在软件行业并不陌生。三层架构是一种成熟的软件应用程序架构，它将应用程序分为三个逻辑和物理计算层：呈现层（或用户界面）、应用层（处理数据）和数据层（存储和管理与应用程序相关的数据）。</p>

<p>分层存储指的是一种存储架构，它根据数据的访问模式、性能要求和成本考虑，使用不同类别或层级的存储来有效地管理和存储数据。这样可以确保最重要和最频繁访问的数据保存在高性能的 “热 “存储（本地）中，而不太重要或不太频繁访问的数据则转移到成本较低、性能较低的 “热 “存储（远程）中。</p>

<p>我们还可以将 “冷 “存储定义为定期备份系统，但这通常是一个单独的流程。这三个层级如下图 1 所示。</p>

<p><img src="https://developers.redhat.com/sites/default/files/tiers-smaller.png.webp" alt="Tiers of storage" /></p>

<p>使用分层存储时，数据在任何时候都停留在一种介质类型上，并随着数据访问模式的变化在介质之间移动。数据不是复制，而是移动到不同的存储介质上，选择最能平衡可用性、性能和存储介质成本的位置。这样，就能更好地利用存储硬件，同时最大限度地提高关键任务应用程序的性能。某些数据可能仍被缓存，但这只是出于性能考虑。</p>

<h2 id="the-need-for-remote-storage">The need for remote storage</h2>

<p>Apache Kafka 设计用于从数千个客户端摄取大量数据。到目前为止，一个Topic分区的副本是由多个分段文件(Segment)组成的，而这些分段文件完全托管在 Kafka 代理的单个磁盘上，因此你可以存储的数据量是有限的。</p>

<p>如果要保存历史数据怎么办？这就是需要远程存储的地方。常规主题的历史数据需要存储在某个地方。事件来源和变更数据捕获是两种可能需要历史数据的架构模式。我们可能需要它们来进行灾难恢复、初始化新的应用程序、在修复业务逻辑问题后重建应用程序状态、重新训练机器学习模型。</p>

<p>在 Kafka 外部保存历史数据基本上有两种方法：</p>

<ul>
  <li>通过额外进程将Kafka中的数据全部读取并拷贝至远程存储。这样做的缺点是，数据消费者必须根据数据的年龄构建不同版本的应用程序，以便从不同的系统中读取数据。有时，需要使用 Kafka Connect 来导出和导入数据。</li>
  <li>使用运行在 Kafka 机器上的自定义程序，检查不活动的数据段，并将其移动到远程存储中。这些段已达到 <code class="language-plaintext highlighter-rouge">segment.bytes</code> 所定义的最大大小，并已关闭和以只读方式重新打开。这种解决方案的优点是无需向 Kafka 回馈重新处理的成本，但需要维护另一个程序。</li>
</ul>

<h2 id="tiered-storage-in-kafka">Tiered storage in Kafka</h2>

<p>自定义程序解决方案类似于 Kafka 3.6.0 中作为早期访问发布的新分层存储功能（KIP-405）。这项新功能提供了一种标准化的内置机制，可根据保留配置自动将本地存储（如 SSD/NVMe）中的非活动片段移动到远程存储（如 S3/HDFS），并在客户端要求时从远程存储读回数据。可以通过插件支持各种外部存储系统，这些插件并不是 Kafka 项目的一部分。</p>

<p>分层存储必须在Cluster级别通过 <code class="language-plaintext highlighter-rouge">remote.log.storage.system.enable</code> 启用，在Topic级别通过 <code class="language-plaintext highlighter-rouge">remote.storage.enable</code> 启用。在Topic级别可以配置两种保留期：本地存储的保留期为 <code class="language-plaintext highlighter-rouge">local.log.retention.ms</code>，远程存储的保留期为 <code class="language-plaintext highlighter-rouge">log.retention.ms</code>（也可使用基于大小的保留期）。</p>

<p>Kafka Broker 会尽快将数据移动到远程存储，但在某些情况下，如高摄取率(ingestion rate)或连接问题，本地存储中存储的数据可能会多于指定的本地保留策略。任何超过本地保留阈值的数据在成功上传到远程存储之前都不会被清除。只有Leader节点的非活动日志段才会上载到远程存储，而不是Followers，但你仍然可以从Followers那里获取数据。</p>

<p>当消费者请求本地尚未提供但在可用偏移范围内的记录（信息）时，Broker会从远程存储中获取它们，并在本地缓存索引文件。因此建议为此预留磁盘空间（默认为 1 GiB，可通过 <code class="language-plaintext highlighter-rouge">remote.log.index.file.cache.total.size.bytes</code> 进行配置）。</p>

<p>分层存储有多种好处：</p>

<ul>
  <li>弹性(Elasticity)： 计算和存储资源分离，现在可以独立扩展，由于本地数据减少，某些集群操作会变得更快。</li>
  <li>隔离性(Isolation)： 对延迟敏感的数据可照常从本地层提供，而历史数据可使用不同的代码路径和线程从远程层提供，无需更改 Kafka 客户端。</li>
  <li>成本效益(Cost efficiency)： 远程对象存储系统的成本低于本地快速磁盘。Kafka 存储变得更便宜，而且几乎不受限制。</li>
</ul>

<p>此外还有一些限制，将在今后的版本中加以解决：</p>

<ul>
  <li>不支持多个日志目录 (JBOD) 和压缩Topic（包括转换为常规Topic的压缩Topic）。</li>
  <li>要在Topic上禁用分层，需要先将数据传输到另一个Topic或外部存储，然后删除Topic。</li>
</ul>

<p>一个仍在开发中的重要功能是可以动态设置Broker级配额，以限制我们上传和下载段(segments)的速度（KIP-956）。这对于避免过度使用Broker资源和远程存储性能下降非常有用。例如，在现有Topic上首次启用分层存储时就会出现这种情况。</p>

<p>远程存储操作有几个指标，可用于监控和创建有关远程存储服务的告警（例如，缓慢的远程上传/下载速率、高远程上传/下载错误率、繁忙的上传/下载线程池）。</p>

<p>在 Kafka 3.7.0 中，有新指标可报告每个Topic的段或字节复制和删除滞后情况：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">kafka.server:type=BrokerTopicMetrics,name=RemoteCopyLagSegments,topic=([-.w]+)</code></li>
  <li><code class="language-plaintext highlighter-rouge">kafka.server:type=BrokerTopicMetrics,name=RemoteCopyLagBytes,topic=([-.w]+)</code></li>
  <li><code class="language-plaintext highlighter-rouge">kafka.server:type=BrokerTopicMetrics,name=RemoteDeleteLagBytes,topic=([-.w]+)</code></li>
  <li><code class="language-plaintext highlighter-rouge">kafka.server:type=BrokerTopicMetrics,name=RemoteDeleteLagSegments,topic=([-.w]+)</code></li>
</ul>

<h2 id="kafka-internals">Kafka internals</h2>

<p>现在，我们将深入了解 Apache Kafka 的内部结构，看看消息是如何产生和消费的。然后，我们将了解分层存储如何与之集成，以及所有组件如何相互配合。如果您已经熟悉 Kafka 存储的内部结构，可以直接跳到分层存储如何工作部分。</p>

<h3 id="how-records-are-stored">How records are stored</h3>

<p>让我们先看看记录是如何存储在磁盘上的。在 Kafka 中，我们有两个主要的子系统：由处理用户数据的组件组成的 “数据平面 “和由处理集群元数据（控制器选举、Topic配置和集群）的组件组成的 “控制平面”。如图 2 所示。</p>

<p><img src="https://developers.redhat.com/sites/default/files/2024-02-08-kafka-tiered-storage-deep-dive-fig2.png" alt="Data and control planes" /></p>

<blockquote>
  <p>默认情况下，当一批新的记录到达时，它会首先写入操作系统的页面缓存(Page Cache)，然后才异步刷新到磁盘。如果 Kafka JVM 因某种原因崩溃，最近的信息仍在页面缓存中，并将被操作系统刷新。但是，这并不能防止机器崩溃时数据丢失。这就是启用主题复制的重要原因：拥有多个复制意味着只有多个代理同时崩溃时，数据才有可能丢失。为了进一步提高容错能力，可以使用机架感知的 Kafka 集群，将Topic副本均匀地分布在同一地理区域的数据中心中。</p>
</blockquote>

<p>当应用程序调用 <code class="language-plaintext highlighter-rouge">producer.send()</code> 时，生产者会确定目标 Broker。记录可能不会立即发送，而是会根据时间或大小配置属性进行累积并批量发送。Broker 的网络线程之一会接收到 <code class="language-plaintext highlighter-rouge">ProduceRequest</code>，该网络线程将请求转换为 <code class="language-plaintext highlighter-rouge">ProduceRequest</code> 并传递给 IO 线程。在将数据追加到分区段（日志和索引文件）之前，IO 线程会对请求进行验证。参见图3。</p>

<p><img src="https://developers.redhat.com/sites/default/files/data-plane.png" alt="Data plane message flow" /></p>

<p>默认情况下，只有在生产请求被其他Broker复制后，Broker才会确认该请求。这不会阻塞 IO 线程。复制完成后，Broker会生成一个<code class="language-plaintext highlighter-rouge">ProduceResponse</code>。最后，网络线程将该响应发送给生产者。</p>

<p>Kafka 消费者发送 Fetch 请求，指定所需的Topic、分区和偏移量。代理的网络线程会将请求传递给 IO 线程，IO 线程会将偏移量与段索引文件中的相应条目进行比较。这一步决定了从日志文件中读取的确切字节数。</p>

<h2 id="how-tiered-storage-works">How tiered storage works</h2>

<p>日志段(log segment)由记录数据和相关元数据组成，覆盖分区副本中连续的偏移范围。在Broker的磁盘上，这些数据存储在多个文件中，日志本身保存记录批次，索引文件支持对日志的有效访问，等等。分层存储功能包括将这些文件移入或移出远程对象存储。</p>

<p>为了向日志添加数据，IO 线程会通知 ReplicaManager，这就是分层存储的插件。主要组件包括 <code class="language-plaintext highlighter-rouge">RemoteLogManager（RLM）</code>、<code class="language-plaintext highlighter-rouge">RemoteStorageManager（RSM）</code>和 <code class="language-plaintext highlighter-rouge">RemoteLogMetadataManager（RLMM）</code>。<code class="language-plaintext highlighter-rouge">RSM</code> 和 <code class="language-plaintext highlighter-rouge">RLMM</code> 都是可插拔接口，因此可以支持不同类型的远程存储系统。如图 4 所示。</p>

<p><img src="https://developers.redhat.com/sites/default/files/2024-02-08-kafka-tiered-storage-deep-dive-fig4.png" alt="Tiered storage high level architecture" /></p>

<p>出于性能考虑，使用了两个缓存。由 <code class="language-plaintext highlighter-rouge">TopicBasedRemoteLogMetadataManager</code>（默认 RLMM 实现）维护的内存 <code class="language-plaintext highlighter-rouge">RemoteLogMetadataCache</code>，其中包含所有未删除的远程分段的元数据。由 <code class="language-plaintext highlighter-rouge">RemoteLogManager </code>维护并存储在 <code class="language-plaintext highlighter-rouge">remote-log-index-cache </code>文件夹中的基于文件的 <code class="language-plaintext highlighter-rouge">RemoteIndexCache</code>，有助于避免每次获取调用都从远程存储中重新获取偏移量、时间索引等索引文件。</p>

<h3 id="remotestoragemanager">RemoteStorageManager</h3>

<p><code class="language-plaintext highlighter-rouge">RemoteStorageManager</code> 提供了远程日志段的生命周期，包括从远程存储中复制、获取和删除。</p>

<p><code class="language-plaintext highlighter-rouge">RemoteStorageManager</code> 提供的日志段元数据是 <code class="language-plaintext highlighter-rouge">RemoteLogSegmentMetadata</code> 实例，它描述了上传到远程存储的日志段。它包含一个普遍唯一的 <code class="language-plaintext highlighter-rouge">RemoteLogSegmentId</code>，是已外部化到远程存储的段数据的标识符。<code class="language-plaintext highlighter-rouge">RemoteLogSegmentId</code> 由Topic名称、Topic ID、分区编号和 UUID 组成。</p>

<p>日志段数据（LogSegmentData）包含需要存储在远程存储中的特定日志段的实际数据和索引。</p>

<p>这就是带有索引和辅助状态的远程段在远程存储中的样子：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test-0-00000000000000000000-knnxbs3FSRyKdPcSAOQC-w.index
test-0-00000000000000000000-knnxbs3FSRyKdPcSAOQC-w.snapshot
test-0-00000000000000000000-knnxbs3FSRyKdPcSAOQC-w.leader_epoch_checkpoint
test-0-00000000000000000000-knnxbs3FSRyKdPcSAOQC-w.timeindex
test-0-00000000000000000000-knnxbs3FSRyKdPcSAOQC-w.log
test-0-00000000000000001005-SpGkL2YWRMC5DIw5TJP_EA.index
test-0-00000000000000001005-SpGkL2YWRMC5DIw5TJP_EA.leader_epoch_checkpoint
test-0-00000000000000001005-SpGkL2YWRMC5DIw5TJP_EA.log
test-0-00000000000000001005-SpGkL2YWRMC5DIw5TJP_EA.snapshot
test-0-00000000000000001005-SpGkL2YWRMC5DIw5TJP_EA.timeindex
</code></pre></div></div>

<p>文件名不一定必须是这种格式，它由 <code class="language-plaintext highlighter-rouge">RemoteStorageManager</code> 插件定义，但基本上，它通常包含这些信息，以便相互区分：</p>

<ul>
  <li>Topic name</li>
  <li>Partition ID</li>
  <li>Log segment base offset</li>
  <li>Remote segment UUID</li>
  <li>FILE_TYPE</li>
</ul>

<p>FILE_TYPE 可以是以下类型之一：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">leader-epoch-checkpoint</code> 文件，其中包含该分区的 <code class="language-plaintext highlighter-rouge">leader_epoch</code> 到 <code class="language-plaintext highlighter-rouge">start_offset</code> 映射的元数据。</li>
  <li>偏移索引文件，包含日志段的偏移索引。</li>
  <li>时间索引文件包含日志段的时间索引。</li>
  <li>生产者快照文件包含生产者 ID 与某些元数据（如日志段的序列号和纪元）的映射。</li>
  <li>可选的事务索引文件包含日志段的中止事务。这是一个可选文件，只有在启用事务生产者时才会存在。</li>
</ul>

<p>需要注意的是，虽然 KIP-405 中的规范并不强制执行存储在远程存储器中的文件名格式，但在从远程存储器获取数据时，除了可选的事务索引外，任何丢失的文件都会导致异常和获取失败。</p>

<h3 id="remotelogmetadatamanager">RemoteLogMetadataManager</h3>

<p><code class="language-plaintext highlighter-rouge">RemoteLogMetadataManager</code> 用于存储关于上传段的 <code class="language-plaintext highlighter-rouge">RemoteLogSegmentMetadata</code>，需要一个支持强一致性的存储系统，而有些存储系统只支持最终一致性。</p>

<p>这就是 Kafka 提供基于Topic的 <code class="language-plaintext highlighter-rouge">TopicBasedRemoteLogMetadataManager</code> 的原因，它使用名为 <code class="language-plaintext highlighter-rouge">__remote_log_metadata</code> 的内部非压缩Topic来存储元数据记录。每个元数据操作都有一个相关的记录类型，该类型定义在 <code class="language-plaintext highlighter-rouge">storage/src/main/resources/message</code> 中。</p>

<h3 id="remotelogmanager">RemoteLogManager</h3>

<p>启用分层存储后，Broker会启动 <code class="language-plaintext highlighter-rouge">RemoteLogManager</code>，该组件负责维护拥有远程日志段的Topic分区列表。它负责初始化 <code class="language-plaintext highlighter-rouge">RemoteStorageManager</code> 和 <code class="language-plaintext highlighter-rouge">RemoteLogMetadataManager</code>，处理有关Leader节点/Follower节点的变更和分区停止的事件，向其他Broker侧组件提供操作以获取有关远程日志段的索引和元数据。</p>

<p>当所有组件启动后，<code class="language-plaintext highlighter-rouge">ReplicaManager</code> 会等待副本对任意分区获取领导权（leadership）。</p>

<p>此时，系统会为每个受管理的Topic分区创建一个<code class="language-plaintext highlighter-rouge">RLMTask</code>，并通过 <code class="language-plaintext highlighter-rouge">RLMScheduledThreadPool</code> 按 <code class="language-plaintext highlighter-rouge">remote.log.manager.task.interval.ms</code> 配置的间隔周期性地调度执行。</p>

<p>当每次调度执行时，<code class="language-plaintext highlighter-rouge">RLMTask</code>会执行两个子任务：</p>

<ul>
  <li>将日志段（log segments）复制到远程存储</li>
  <li>从远程存储中删除日志段</li>
</ul>

<h3 id="logsegment-copy">LogSegment copy</h3>

<p>为了确定哪些 LogSegment 符合复制到远端存储的条件，RLMTask 会比较两个偏移量：</p>

<ol>
  <li><strong>最后稳定偏移量 (LSO)</strong>
    <ul>
      <li>对于非事务性记录：等于高水位线（high watermark）</li>
      <li>对于事务性记录：等于最后提交的偏移量</li>
    </ul>
  </li>
  <li><strong>最后远端偏移量 (LRO)</strong>
    <ul>
      <li>表示已存储在远端存储中的最后偏移量</li>
      <li>通过 RemoteLogMetadataManager 获取</li>
    </ul>
  </li>
</ol>

<p>当 LSO &gt; LRO 时，RLMTask 会检查该偏移量范围内是否存在任何非活跃状态的 segment。这些非活跃 segment 即符合复制到远端存储的条件。该过程的示意图可参考图5。</p>

<p><img src="https://developers.redhat.com/sites/default/files/2024-02-08-kafka-tiered-storage-deep-dive-fig5.png" alt="Sequence diagram for segment copy" /></p>

<h3 id="logsegment-deletion">LogSegment deletion</h3>

<p>远程日志保留机制与本地日志保留机制类似，区别在于日志段存储于远程存储中。其核心逻辑依然是通过 <code class="language-plaintext highlighter-rouge">retention.bytes</code> 或 <code class="language-plaintext highlighter-rouge">retention.ms</code> 参数删除旧的日志段。</p>

<p>RLMTask 严重依赖 <code class="language-plaintext highlighter-rouge">RemoteLogMetadataManager</code> 中存储的元数据来识别待删除的候选日志段。需注意：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">retention.bytes</code> 的计算范围：包含本地日志段与远程日志段的总大小</li>
  <li><code class="language-plaintext highlighter-rouge">retention.ms</code> 的判定基准：同时覆盖本地与远程的日志时间戳</li>
</ul>

<h3 id="consumer-fetch">Consumer fetch</h3>

<p>针对分层存储场景，消费者Fetch请求的处理逻辑发生如下变更。</p>

<p>当所需偏移量数据已迁移至远程存储时，<code class="language-plaintext highlighter-rouge">ReplicaManager</code>将抛出<code class="language-plaintext highlighter-rouge">OffsetOutOfRangeException</code>。此时系统会将请求暂存至<code class="language-plaintext highlighter-rouge">RemoteFetchPurgatory</code>队列，并通过向<code class="language-plaintext highlighter-rouge">RemoteStorageThreadPool</code>线程池提交<code class="language-plaintext highlighter-rouge">RemoteLogReader</code>任务的方式，将该请求委托给<code class="language-plaintext highlighter-rouge">RemoteLogManager</code>处理。</p>

<p>每个<code class="language-plaintext highlighter-rouge">RemoteLogReader</code>每次仅处理一个远程Fetch请求。当远程读取请求处于<code class="language-plaintext highlighter-rouge">RemoteFetchPurgatory</code>等待队列时，当前系统会复用<code class="language-plaintext highlighter-rouge">fetch.max.wait.ms</code>作为延迟超时参数。</p>

<p>这种设计存在明显缺陷，因为该参数原始设计用途是控制当本地无可用数据时Fetch请求的等待时长。根据KIP-1018提案，后续将通过引入远程读取延迟超时（remote fetch delay timeout）专用配置参数来优化此问题，具体架构如图6所示。</p>

<p><img src="https://developers.redhat.com/sites/default/files/2024-02-08-kafka-tiered-storage-deep-dive-fig6.png" alt="Sequence diagram for consumer Fetch request" /></p>

<h3 id="follower-fetch">Follower fetch</h3>

<p>对于采用分层存储的Topic，Follower副本的同步逻辑有如下重要调整：当Follower分区副本从Leader获取数据时若触发<code class="language-plaintext highlighter-rouge">OffsetMovedToTieredStorageException</code>异常，即表明请求的offset数据已不在Leader本地存储中，此时Follower需基于远端分段元数据（remote segment metadata）重建辅助状态。</p>

<p>副本的辅助状态包括<code class="language-plaintext highlighter-rouge">leader-epoch</code>检查点（日志复制协议用它来维护Broker间的日志一致性）和producer-id快照（事务子系统使用它）。</p>

<p>副本会调用带有<code class="language-plaintext highlighter-rouge">EarliestLocalTimestamp</code>参数的<code class="language-plaintext highlighter-rouge">ListsOffsets</code> API来确定需要重建该状态的截止偏移量。在辅助状态构建完成后，副本将截断本地日志，将拉取偏移量重置为远端日志末端偏移量加1，然后恢复从leader本地存储拉取数据。</p>

<h2 id="conclusion">Conclusion</h2>

<p>我们深入探讨了Kafka采用远端存储的必要性，特别是对于容灾恢复、数据分析和机器学习等关键场景中历史数据的保留需求。</p>

<p>Kafka分层存储的引入提供了一个标准化、内建的解决方案。通过基于数据访问模式、性能需求和成本考量配置不同存储层级，该方案在确保高效数据管理的同时，实现了资源利用的最优化。</p>

<p>我们还解析了支撑远端日志子系统的技术架构，详细阐释了<code class="language-plaintext highlighter-rouge">RemoteLogManager</code>（远端日志管理器）、<code class="language-plaintext highlighter-rouge">RemoteStorageManager</code>（远端存储管理器）和<code class="language-plaintext highlighter-rouge">RemoteLogMetadataManager</code>（远端日志元数据管理器）等组件的功能。</p>

<p>分层存储代表着Kafka生态系统在数据管理领域的重要突破，为现代化分布式架构提供了兼顾存储效率与检索性能的稳健解决方案。</p>]]></content><author><name>GitHub User</name></author><category term="Kafka" /><category term="Kafka" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">关于MySQL8.4LTS你应该知道的事情</title><link href="http://localhost:4000/mysql/2025/05/27/%E5%85%B3%E4%BA%8EMySQL8.4LTS%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85.html" rel="alternate" type="text/html" title="关于MySQL8.4LTS你应该知道的事情" /><published>2025-05-27T00:00:00+08:00</published><updated>2025-05-27T00:00:00+08:00</updated><id>http://localhost:4000/mysql/2025/05/27/%E5%85%B3%E4%BA%8EMySQL8.4LTS%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85</id><content type="html" xml:base="http://localhost:4000/mysql/2025/05/27/%E5%85%B3%E4%BA%8EMySQL8.4LTS%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85.html"><![CDATA[<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/MySQL8.4.jpeg?raw=true" alt="banner" /></p>

<h2 id="mysql-84">MySQL 8.4</h2>

<p>MySQL8.4是官方第一个正式指定为长期支持（LTS）版本，也是一个重要的里程碑版本，MySQL官方对该版本将提供长达五年的主要支持和额外的三年扩展支持，总支持周期预计持续到 2032 年 4 月左右。</p>

<p>与此前的 MySQL 8.0 版本相比，MySQL 8.4 引入了诸多变化，包括功能成熟化为默认设置、部分功能被弃用或移除。但在8.4中，并未引入新的“革命性的新特性”，更多的是对部分参数的小调整，以及性能的优化提升。</p>

<p>本篇，我就来一起看一下MySQL8.4对比8.0版本，有哪些改变。</p>

<h2 id="performance-improvement"><em>Performance improvement</em></h2>

<p>MySQL 8.4 在性能方面取得了显著进步，特别是在特定工作负载和内部机制上进行了优化，旨在提供更快的查询执行、更高的响应速度以及更流畅的数据库操作 。</p>

<p>首先，多项 InnoDB 存储引擎相关的系统变量默认值得到了调整，以更好地适应现代硬件能力并提升性能。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">innodb_buffer_pool_in_core_file</code> 的默认值从 <code class="language-plaintext highlighter-rouge">ON</code> 变为 <code class="language-plaintext highlighter-rouge">OFF</code>，这有助于通过移除大型 InnoDB 的缓冲池数据包含在核心转储文件中，以此来减小核心文件大小 。</li>
  <li><code class="language-plaintext highlighter-rouge">innodb_change_buffering</code> 的默认值从 <code class="language-plaintext highlighter-rouge">all</code> 变为 <code class="language-plaintext highlighter-rouge">none</code>，这意味着不再缓存索引更改，这在 SSD 上尤其能带来更快的写入速度 。</li>
  <li><code class="language-plaintext highlighter-rouge">innodb_flush_method</code> 在 Linux 上的默认值从 <code class="language-plaintext highlighter-rouge">fsync</code> 变为 <code class="language-plaintext highlighter-rouge">O_DIRECT</code>（如果支持），这更符合现代硬件特性，特别是对于 SSD 和 RAID 系统 。</li>
  <li><code class="language-plaintext highlighter-rouge">innodb_log_buffer_size</code> 的默认值从 16 MB 增加到 64 MB，更大的日志缓冲区可以减少日志写入频率，从而提升性能 。</li>
  <li><code class="language-plaintext highlighter-rouge">temptable_max_ram</code> 的默认值也从 1 GB 动态调整为总内存的 3%（在 1-4 GB 范围内），这使得内存分配更加灵活，平衡了性能与稳定性 。</li>
</ul>

<table>
  <thead>
    <tr>
      <th>变量名</th>
      <th>MySQL 8.0 默认值</th>
      <th>MySQL 8.4 默认值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>innodb_buffer_pool_in_core_file</td>
      <td>ON</td>
      <td>OFF（如果支持 MADV_DONTDUMP）</td>
    </tr>
    <tr>
      <td>innodb_change_buffering</td>
      <td>all</td>
      <td>none</td>
    </tr>
    <tr>
      <td>innodb_adaptive_hash_index</td>
      <td>ON</td>
      <td>OFF</td>
    </tr>
    <tr>
      <td>innodb_doublewrite_pages</td>
      <td>innodb_write_io_threads (4)</td>
      <td>128</td>
    </tr>
    <tr>
      <td>innodb_flush_method (Linux)</td>
      <td>fsync</td>
      <td>O_DIRECT（如果支持）</td>
    </tr>
    <tr>
      <td>innodb_io_capacity</td>
      <td>200</td>
      <td>10000</td>
    </tr>
    <tr>
      <td>innodb_log_buffer_size</td>
      <td>16 MB</td>
      <td>64 MB</td>
    </tr>
    <tr>
      <td>temptable_max_ram</td>
      <td>1 GB</td>
      <td>总内存的 3%（1-4 GB）</td>
    </tr>
  </tbody>
</table>

<p>其次，更深层次的性能优化体现在以下几个关键领域：</p>

<ul>
  <li><strong>Binlog 事务依赖性优化：</strong> MySQL 8.4 将 <code class="language-plaintext highlighter-rouge">binlog_transaction_dependency</code> 的数据结构从 <code class="language-plaintext highlighter-rouge">std::map</code> 切换到 <code class="language-plaintext highlighter-rouge">ankerl::unordered_dense::map</code> 。这一改变显著提升了 <code class="language-plaintext highlighter-rouge">INLIST_UPDATE</code> 和 <code class="language-plaintext highlighter-rouge">UPDATE_INDEX_LIMIT</code> 等工作负载的效率，带来了高达 <strong>19.4% 的平均性能提升</strong> 。这种内部数据结构的变化，直接解决了特定高并发场景下的瓶颈，对于依赖这些操作的应用程序而言，性能增益将尤为明显。</li>
  <li><strong>JOIN 查询执行优化：</strong> MySQL 8.4 解决了在 MySQL 8.0.33 版本中相对于 8.0.28 版本在使用 <code class="language-plaintext highlighter-rouge">JOIN</code> 查询时出现的性能下降问题 。这项优化为 <code class="language-plaintext highlighter-rouge">POINTS_COVERED_SI</code> 和 <code class="language-plaintext highlighter-rouge">POINTS_NOTCOVERED_SI</code> 等工作负载带来了 <strong>2.17% 的平均性能提升</strong> 。这表明开发团队通过深入分析并修复了特定查询模式下的低效问题，使得复杂的联接操作更为高效。</li>
  <li><strong>索引范围扫描改进：</strong> 在之前的 MySQL 版本中，索引范围扫描缺少记录缓冲区导致了不必要的性能下降 。最新版本解决了这一问题，为 <code class="language-plaintext highlighter-rouge">ORDER_RANGES</code>、<code class="language-plaintext highlighter-rouge">RANGE_NOTCOVERED</code>、<code class="language-plaintext highlighter-rouge">RANGE_COVERED</code> 和 <code class="language-plaintext highlighter-rouge">SUM_RANGES</code> 等多种工作负载带来了 <strong>2.12% 的平均性能提升</strong> 。这一改进直接提升了依赖索引扫描的读取密集型操作的效率。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">innodb_doublewrite_pages</code> 默认值调整：</strong> MySQL 8.4 将 <code class="language-plaintext highlighter-rouge">innodb_doublewrite_pages</code> 的默认值从 MySQL 8.0.20 的 4 调整为 128 。这一更改修复了之前版本中一个次优行为，该行为可能导致在使用 <code class="language-plaintext highlighter-rouge">ALTER TABLE</code> 的 <code class="language-plaintext highlighter-rouge">INPLACE</code> 算法等操作时出现性能下降。</li>
</ul>

<p>总体而言，这些优化带来了显著的性能提升：写入工作负载平均性能提升约 <strong>7.25%</strong>，读取工作负载平均性能提升约 <strong>1.39%</strong> 。</p>

<h2 id="security-enhancement"><em>Security enhancement</em></h2>

<p>MySQL 8.4 在安全性方面进行了多项重要强化，为用户提供了更强大的数据保护和更灵活的身份验证机制。</p>

<p><strong>默认认证插件变化：</strong> <code class="language-plaintext highlighter-rouge">MySQL 8.0</code> 使用 <code class="language-plaintext highlighter-rouge">caching_sha2_password</code> 作为默认插件，但 <code class="language-plaintext highlighter-rouge">mysql_native_password</code> 仍可用。</p>

<p><code class="language-plaintext highlighter-rouge">MySQL 8.4</code> 中，<code class="language-plaintext highlighter-rouge">mysql_native_password</code>默认被禁用，必须通过 –mysql-native-password=ON 或在 [mysqld] 部分添加 mysql_native_password=ON 启用。Percona 文章指出，这与 MySQL 8.0.34 的弃用趋势一致，预计在 MySQL 9.0 中完全移除，研究显示这提升了安全性，但可能影响旧系统兼容性。</p>

<p><strong>SASL 基于 LDAP 认证：</strong> MySQL 8.4 在 Windows 上支持 GSSAPI/Kerberos 的 SASL 认证，使用 <code class="language-plaintext highlighter-rouge">authentication_ldap_sasl_client</code> 插件，适合企业级身份验证场景。</p>

<p><strong>WebAuthn 认证：</strong> 新增 <code class="language-plaintext highlighter-rouge">authentication_webauthn</code>（服务器端，企业版）和 <code class="language-plaintext highlighter-rouge">authentication_webauthn_client</code>（客户端）插件，支持智能卡等设备认证，增强了多因素认证能力。</p>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>MySQL 8.0</th>
      <th>MySQL 8.4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>默认认证插件</td>
      <td>caching_sha2_password，可用 mysql_native_password</td>
      <td>caching_sha2_password，mysql_native_password 默认禁用</td>
    </tr>
    <tr>
      <td>SASL LDAP 认证</td>
      <td>不支持 Windows GSSAPI/Kerberos</td>
      <td>支持 Windows GSSAPI/Kerberos</td>
    </tr>
    <tr>
      <td>WebAuthn 认证</td>
      <td>不支持</td>
      <td>支持（企业版）</td>
    </tr>
  </tbody>
</table>

<h2 id="replication-enhancement"><em>Replication Enhancement</em></h2>

<p>MySQL8.4 对于主从复制方面进行了优化和改进，准确的说，在8.4中，已经不能叫做主从复制了，主要改变如下。</p>

<ul>
  <li>
    <p>MySQL 8.0 使用 MASTER/SLAVE 术语，MySQL 8.4 改为 SOURCE/REPLICA，符合包容性标准，Percona 文章指出这对用户理解复制角色更清晰。</p>

    <p><code class="language-plaintext highlighter-rouge">MASTER</code>/<code class="language-plaintext highlighter-rouge">SLAVE</code> 术语的完全移除 是社会语言变化转化为技术变更的一个典型例子。虽然从道德角度值得称赞，但这一变化对于依赖这些术语的现有自动化脚本、监控工具和自定义指标收集器来说，是一个<strong>破坏性变更</strong> 。这凸显了数据库升级的一个关键方面：需要对所有周边操作工具进行全面审计和更新，而不仅仅是数据库本身。这强调了即使是看似“非技术性”的更改，如果不在升级周期中主动解决，也可能导致显著的技术债务。</p>
  </li>
  <li>
    <p><strong>GTID 标签：</strong> 新增支持，格式为 UUID:TAG:NUMBER，通过 gtid_next=AUTOMATIC:TAG 或 UUID:TAG:NUMBER 启用，需要 TRANSACTION_GTID_TAG 权限。官方文档提到这便于事务组跟踪，适合复杂复制环境。</p>
  </li>
  <li>
    <p><strong>SQL_AFTER_GTIDS：</strong> 现在兼容多线程应用器（MTA），提升复制性能。</p>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>MySQL 8.0</th>
      <th>MySQL 8.4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>复制术语</td>
      <td>MASTER/SLAVE</td>
      <td>SOURCE/REPLICA</td>
    </tr>
    <tr>
      <td>SOURCE_RETRY_COUNT 默认值</td>
      <td>未指定</td>
      <td>10</td>
    </tr>
    <tr>
      <td>GTID 标签</td>
      <td>不支持</td>
      <td>支持（UUID:TAG:NUMBER）</td>
    </tr>
    <tr>
      <td>SQL_AFTER_GTIDS</td>
      <td>不兼容 MTA</td>
      <td>兼容 MTA</td>
    </tr>
  </tbody>
</table>

<h2 id="foreign-key-constraint"><em>Foreign key constraint</em></h2>

<p>MySQL 8.0 允许父表上的索引不一定是唯一的，MySQL 8.4 要求引用列上必须有唯一键，由 <code class="language-plaintext highlighter-rouge">restrict_fk_on_non_standard_key</code> 控制（默认 ON）。Percona 文章指出，这增强了数据完整性，但可能需要调整现有架构。</p>

<p>此项变更对于强制执行更严格的关系完整性至关重要，更重要的是，它旨在防止在使用多线程应用器时，父表上没有唯一键可能导致的随机复制中断 。因此，以前可用的创建外键的 DDL 语句现在可能会失败。组织必须审查其模式和 DDL 脚本，以确保引用父列上存在唯一键。这是朝着改进数据一致性和复制可靠性迈出的重要一步。</p>

<h2 id="key-removal"><em>Key removal</em></h2>

<p>MySQL 8.4 的发布，伴随着一些功能的弃用和移除，这些变化可能对现有系统和升级过程产生显著影响。</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">AUTO_INCREMENT</code> 与 <code class="language-plaintext highlighter-rouge">FLOAT</code> 或 <code class="language-plaintext highlighter-rouge">DOUBLE</code> 数据类型：</strong> 这种组合在 MySQL 8.0 中已被弃用，并在 8.4 中<strong>完全移除</strong>。尝试在 <code class="language-plaintext highlighter-rouge">FLOAT</code> 或 <code class="language-plaintext highlighter-rouge">DOUBLE</code> 列上使用 <code class="language-plaintext highlighter-rouge">AUTO_INCREMENT</code> 选项创建或修改表将导致错误 。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">FLUSH HOSTS</code> 语句：</strong> 该语句已在 MySQL 8.4 中移除。推荐的替代方法是使用 <code class="language-plaintext highlighter-rouge">TRUNCATE TABLE performance_schema.host_cache</code> 。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">SET_USER_ID</code> 权限：</strong> 该权限在 MySQL 8.2 中被弃用，并已在 8.4 中完全移除。其职责被拆分为 <code class="language-plaintext highlighter-rouge">SET_ANY_DEFINER</code> 和 <code class="language-plaintext highlighter-rouge">ALLOW_NONEXISTENT_DEFINER</code> 。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">default_authentication_plugin</code> 变量：</strong> 该系统变量已在 MySQL 8.4 中移除 。数据库系统现在将始终默认为新用户使用 <code class="language-plaintext highlighter-rouge">caching_sha2_password</code>，忽略任何先前的 <code class="language-plaintext highlighter-rouge">default_authentication_plugin</code> 设置。用户账户仍然可以通过 <code class="language-plaintext highlighter-rouge">CREATE USER</code> 和 <code class="language-plaintext highlighter-rouge">ALTER USER</code> 语句覆盖此默认值 。</li>
  <li><strong>复制相关状态变量：</strong> 多个与复制命令相关的 <code class="language-plaintext highlighter-rouge">Com_</code> 状态变量（例如 <code class="language-plaintext highlighter-rouge">Com_change_master</code>、<code class="language-plaintext highlighter-rouge">Com_show_master_status</code>、<code class="language-plaintext highlighter-rouge">Com_show_slave_hosts</code>、<code class="language-plaintext highlighter-rouge">Com_show_slave_status</code>、<code class="language-plaintext highlighter-rouge">Com_slave_start</code>、<code class="language-plaintext highlighter-rouge">Com_slave_stop</code>）已在 8.4 中移除 。查询这些状态变量的监控工具和脚本将失败，需要更新以使用替代方法或新变量。</li>
</ul>

<h2 id="conclusions">Conclusions</h2>

<p>MySQL 8.4 LTS 版本代表了 MySQL 数据库演进中的一个重要进步，它在稳定性、性能和安全性方面带来了显著的提升。总体来说，8.4没有什么革命性的创新，更多的是细节方面的完善，作为LTS，8.4的目标肯定是稳定压倒一切。</p>

<p><strong>总结：</strong></p>

<ul>
  <li><strong>增强的性能：</strong> 通过对 InnoDB 内部机制的优化、JOIN 查询和索引范围扫描的改进，以及更智能的自动直方图更新，MySQL 8.4 提供了可衡量的性能提升，尤其是在写入密集型工作负载和特定查询模式下。</li>
  <li><strong>强化的安全性：</strong> 8.4 版本引入了全面的高级密码管理功能，强制使用更现代、更安全的 TLS 协议，并支持 WebAuthn 和增强的 SASL-based LDAP 等新的身份验证方法，显著提升了数据库的整体安全态势。</li>
  <li><strong>功能成熟与现代化：</strong> 8.4 版本继续完善了 MySQL 8.0 中引入的现代 SQL 功能（如 CTEs 和窗口函数）和 JSON 数据类型处理，并引入了 GTID 标签等复制增强功能，以提高可观察性和弹性。</li>
</ul>]]></content><author><name>GitHub User</name></author><category term="MySQL" /><category term="MySQL" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">关于Redis8.0你需要知道的事情</title><link href="http://localhost:4000/redis/2025/05/15/%E5%85%B3%E4%BA%8ERedis8.0%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85.html" rel="alternate" type="text/html" title="关于Redis8.0你需要知道的事情" /><published>2025-05-15T00:00:00+08:00</published><updated>2025-05-15T00:00:00+08:00</updated><id>http://localhost:4000/redis/2025/05/15/%E5%85%B3%E4%BA%8ERedis8.0%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85</id><content type="html" xml:base="http://localhost:4000/redis/2025/05/15/%E5%85%B3%E4%BA%8ERedis8.0%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85.html"><![CDATA[<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/Redis8%20release.png?raw=true" alt="banner" /></p>

<h2 id="redis-80-is-coming">Redis 8.0 is Coming</h2>

<p>近日，Redis宣布8.0版本正式发布。</p>

<p>官方宣称Redis 8 是迄今为止性能最强、可扩展性最高的 Redis 版本。它拥有超过 30 项性能改进，包括命令速度提升高达 87%，每秒操作吞吐量提升高达 2 倍，复制速度提升高达 18%，以及通过 Redis 查询引擎提供高达 16 倍的查询处理能力。本次发布新增了 8 种数据结构，包括<strong>向量集合 (vector set)、JSON、时间序列</strong>以及五种概率结构，包括<strong>布隆过滤器、布谷鸟过滤器、计数最小化草图、top-k 和 t-digest</strong>（其中一些之前作为单独的 Redis 模块提供）。这些新的数据结构可以帮助用户更好地解决当前用例，并为下一代快速和实时应用构建。</p>

<ul>
  <li>布隆过滤器与布谷鸟过滤器 (<strong>Bloom</strong> filter &amp; <strong>Cuckoo</strong> filter)：用于检查给定值是否已出现在数据流中</li>
  <li>计数最小化草图 (<strong>Count-min</strong> <strong>sketch)</strong>：用于估计给定值在数据流中出现的次数</li>
  <li><strong>top-k</strong>：查找数据流中最频繁的值</li>
  <li><strong>t-digest</strong>：用于查询数据流中哪些值的比例小于 / 大于给定值</li>
</ul>

<p>值得注意的是，Redis8.0调整了其开源协议，采用了OSI （Open Source Initiative）认证的 AGPLv3 许可证，并保留了现有的 RSALv2 和 SSPLv1 许可证选项，这一战略性的许可转变旨在重建与开源社区的信任，同时继续保护软件免受未经授权的商业利用。</p>

<p>下面我们来对Redis8.0的新特效一一进行详解。</p>

<p>https://redis.io/blog/redis-8-ga/</p>

<h2 id="一name-change">一、Name Change</h2>

<p>改名？难道不叫Redis了吗？事实并非如此，在Redis8.0中，将Redis Community Edition 和 Redis Stack 合并为一个名为 Redis Open Source的单一产品，一般来说，我们使用的Redis指的是Redis Community，如果你想要使用部布隆过滤器等特性，你需要安装额外的模块，也就是Redis Stack，两者的区别如下：</p>

<table>
  <thead>
    <tr>
      <th>对比项</th>
      <th>Redis Community Edition</th>
      <th>Redis Stack</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**核心组件**</td>
      <td>仅包含 Redis 开源数据库</td>
      <td>Redis + 多个官方扩展模块</td>
    </tr>
    <tr>
      <td>**包含的模块**</td>
      <td>❌ 无</td>
      <td>✅ RedisSearch（全文搜索）<br />✅ RedisJSON（JSON数据处理）<br />✅ RedisGraph（图数据库）<br />✅ RedisTimeseries（时间序列）<br />✅ RedisBloom（概率数据结构）</td>
    </tr>
    <tr>
      <td>**许可证**</td>
      <td>BSD-3（完全自由使用）</td>
      <td>Redis Source Available License (RSAL)<br />（部分使用受限）</td>
    </tr>
    <tr>
      <td>**适用场景**</td>
      <td>纯 Redis KV 存储</td>
      <td>增强型 Redis，支持搜索、JSON、时序、图数据</td>
    </tr>
    <tr>
      <td>**商业支持**</td>
      <td>❌ 无官方支持</td>
      <td>❌ 无官方支持（需购买 Redis Enterprise）</td>
    </tr>
    <tr>
      <td>**云托管**</td>
      <td>✅ 可商用</td>
      <td>❌ 禁止 SaaS 提供商托管（如 AWS Elasticache 不能直接使用）</td>
    </tr>
    <tr>
      <td>**定位**</td>
      <td>Redis 基础版</td>
      <td>Redis "瑞士军刀" 增强版</td>
    </tr>
  </tbody>
</table>

<p>Redis 8.0 将之前 Redis Stack 中的核心模块（RedisJSON, RediSearch, RedisTimeSeries, RedisBloom）整合到了 Redis Open Source 的核心中。 这意味着这些功能不再需要作为额外的模块安装，而是 Redis Open Source 的内置功能。</p>

<h2 id="二new-data-structures">二、New Data Structures</h2>

<h3 id="vector-sets-beta">Vector Sets (Beta)</h3>

<p>Vector Sets (Beta) 是一种新的数据类型，目前处于测试阶段，专为高维向量搜索而设计，这是AI和机器学习工作负载的关键组成部分。</p>

<p>Vector Sets扩展了 Sorted Sets 的概念，允许存储和查询高维向量嵌入，从而增强了 Redis 在语义搜索和推荐系统等人工智能用例中的能力。</p>

<p>Vector Sets 支持使用余弦或欧几里得距离在 AI 模型中进行相似性搜索，并且设计上与 ML 框架和嵌入输出兼容，它与 Redis Query Engine 中现有的向量搜索功能相辅相成。由于 Vector Sets 仍处于测试阶段 ，其 API 或功能在未来版本中可能会发生变化。</p>

<p>目前阶段，在生产环境中使用时应非常谨慎，具体的使用效果还需要社区的验证。</p>

<h3 id="json">JSON</h3>

<p>JSON是日常开发中再常见不过的数据结果了，在之前的版本中，对于JSON，只能将JSON作为文本存储在String或者Hash中，在业务代码中进行逻辑处理，较为繁琐，Redis 8.0新增了对JSON结构的支持，允许将 JSON 文档存储为 Redis 中的键，从而改进了传统 Redis 用例的处理方式，同时提供了使用 JSONPath 语言来检索和操作文档的命令，可以对 JSON 结构中的特定元素进行细粒度和高效的访问，并且支持对 JSON 文档的部分进行原子更新，而无需先检索整个文档。</p>

<p>原生JSON的支持显著增强了 Redis 处理现代数据格式的能力，JSON格式在 Web 应用程序和 API 中非常常见。这减少了客户端的序列化/反序列化需求，从而提高了性能和开发人员体验。通过直接支持 JSON，Redis 更自然地适用于已经使用 JSON 作为主要数据交换格式的应用程序，简化了数据处理并提高了效率。</p>

<p>Command Doc：https://redis.io/docs/latest/commands/json.set/</p>

<h3 id="time-series">Time Series</h3>

<p>提到时序数据库，你肯定第一反应会想到<em>Prometheus</em>，时序数据库目前是采集系统级监控数据的首选，Redis 8.0中也新增了时序数据结构的支持，允许非常快速地摄取和检索时间序列数据，并利用高效的压缩算法来最大限度地减少内存占用。它还支持定义压缩（下采样）规则，以实现高效的长期存储。</p>

<h3 id="probabilistic-data-structures">Probabilistic Data Structures</h3>

<p>除了已经提供的 HyperLogLog 之外，Redis 8 还引入了五个新的概率数据结构 。这些结构使用户能够更快地获得关于数据流和大型数据集的常见问题的答案 。它们在内存使用和处理速度方面具有显著的优势，但这是以牺牲绝对精度为代价的。新的结构包括用于检查元素是否存在的布隆过滤器和 Cuckoo 过滤器、用于估计元素频率的 Count-min sketch、用于查找最频繁元素的 Top-K 以及用于近似百分位数的 t-digest 6。</p>

<p>这些概率数据结构的加入扩展了 Redis 在实时分析和数据流处理方面的能力，使得能够在资源消耗最小的情况下对大型数据集进行高效的近似查询。在不需要绝对精确的计数或成员检查的场景中，这些概率结构提供了一种高效的替代方案，允许以减少的内存开销更快地获得洞察。</p>

<h2 id="significant-performance-improvements">Significant performance improvements</h2>

<p>Redis 8.0宣称包含超过 30 项性能和资源利用率改进，此次发布实现了 Redis 单个新版本中最大的性能飞跃。</p>

<p>与 Redis 7.2.5 相比，Redis 8 将某些命令的延迟降低了高达 87%。对 149 项测试的基准测试表明，90 个命令的运行速度更快，延迟更低，p50 延迟降低幅度从 5.4% 到 87.4% 不等。经过优化的特定命令包括 GET、EXISTS、LRANGE、HSET、XREAD、SCAN、ZADD、ZUNION、PFCOUNT 和 HSCAN。</p>

<p><img src="https://redis.io/wp-content/uploads/2025/05/Redis-8.0-Blog-Post-Graph.png?&amp;auto=webp&amp;quality=85,75&amp;width=800" alt="performance" /></p>

<p>与之前的版本相比，Redis 8 的每秒操作吞吐量提高了高达 2 倍。吞吐量的显著提高增强了 Redis 处理高并发工作负载和高要求应用程序的能力。</p>

<p>Redis 8.0 中新的复制机制的速度提高了高达 18%。此项改进缩短了初始同步和持续复制所需的时间，从而提高了 Redis 部署的可靠性和可用性。</p>

<p>进行如此大的性能提升，核心基于新的内部架构的演进，Redis8.0中引入了一个新的 I/O 线程实现，具有读写线程，可实现更高的吞吐量，尤其是在多核环境中 。可以通过设置 io-threads 配置参数来启用此功能 。在多核英特尔 CPU 上设置为 8 时，测得的吞吐量提升范围为 37% 到 112%。新的异步 I/O 线程解决方案是事件驱动的，可以更好地并行处理客户端的读写操作，从而提高在高核心数服务器上的可扩展性。</p>

<p>引入读写 I/O 线程标志着 Redis 在命令处理方面从传统的单线程模型发生了重大转变，使其能够更有效地利用现代多核架构来提高吞吐量。虽然 Redis 的单线程特性在简单性和避免锁竞争方面具有优势，但它在历史上限制了其在多核系统上的扩展能力。新的线程模型解决了这个限制。</p>

<p>Redis 8.0 具有改进的复制机制，该机制更高效、更强大，并支持 AOF 偏移量。</p>

<p>在复制过程中，同时启动两个复制流：一个用于传输主节点，另一个用于传输在此期间发生的更改流。这种新机制允许主节点在复制期间以更高的速率处理操作，减少了在主节点上保留更改所需的缓冲区大小，并加快了复制完成速度。</p>

<p><img src="https://redis.io/wp-content/uploads/2025/05/Redis-8.0-Blog-Image.png?&amp;auto=webp&amp;quality=85,75&amp;width=800" alt="replica" /></p>

<p>根据Redis官方文档披露的测试数据，对10 GB数据集进行了完整的同步，其额外的流量为2684亿个写作操作，在复制过程中产生了25 GB的变化。有了新的复制机制，主节点可以在复制过程中以高7.5％的平均速度处理写操作。复制的时间也少18％，主节点上的峰值复制缓冲区大小降低了35％。</p>

<h3 id="others">Others</h3>

<p>除以上新特性之外，本次版本还有其他升级，在此简要介绍：</p>

<ul>
  <li>Query Engine 集成到核心组件，支持搜索、查询和向量工作负载的水平和垂直扩展，水平扩展支持在集群数据库中进行查询，从而允许管理具有索引的非常大的数据集，并通过扩展到更多 Redis 进程来支持更高的读写吞吐量。垂直扩展允许添加更多处理能力来提高查询吞吐量，从而实现比以前高达 16 倍的吞吐量。</li>
  <li>增强功能的哈希命令：
    <ul>
      <li>HGETDEL：获取并删除哈希字段</li>
      <li>HGETEX：获取哈希字段的值，并可选择设置过期时间</li>
      <li>HSETEX：设置哈希字段的值并设置过期时间</li>
    </ul>
  </li>
  <li>ACL增强以及安全漏洞的修复</li>
</ul>

<h2 id="ending">Ending</h2>

<p>以上，就是Redis8.0的简要介绍，本文仅介绍了部分关于Redis8.0的新特性，关于更加详细的信息，还请参阅Redis官方文档。</p>

<p>可以看到，Redis8.0是迄今为止最强大的Redis版本，如今的Redis已不是一个单单的缓存数据库，而是集缓存、搜索、向量、时序数据为一体的强大数据库，关于Redis8.0是实际表现，还是期待社区的更多反馈，也非常期待在生产环境早日使用Redis8.0。</p>

<h3 id="references">References</h3>

<p><code class="language-plaintext highlighter-rouge">[1]</code>: <em>https://redis.io/docs/latest/commands/json.set/</em></p>]]></content><author><name>GitHub User</name></author><category term="Redis" /><category term="Redis" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Nacos配置无法自动刷新问题排查</title><link href="http://localhost:4000/others/2025/04/28/Nacos%E9%85%8D%E7%BD%AE%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.html" rel="alternate" type="text/html" title="Nacos配置无法自动刷新问题排查" /><published>2025-04-28T00:00:00+08:00</published><updated>2025-04-28T00:00:00+08:00</updated><id>http://localhost:4000/others/2025/04/28/Nacos%E9%85%8D%E7%BD%AE%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5</id><content type="html" xml:base="http://localhost:4000/others/2025/04/28/Nacos%E9%85%8D%E7%BD%AE%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.html"><![CDATA[<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/Nacos%20Logo.jpeg?raw=true" alt="banner" /></p>

<h2 id="背景">背景</h2>

<p>Nacos SpringBoot版本中，提供了<code class="language-plaintext highlighter-rouge">@NacosValue</code>注解，支持控制台修改值时，自动刷新，但是今天遇见了无法自动刷新的问题。</p>

<h2 id="环境">环境</h2>
<p>SpringBoot 2.2.x
nacos-client：2.1.0
nacos-config-spring-boot-starter：0.2.12</p>

<h2 id="问题排查">问题排查</h2>
<p>首先确认，nacos的配置信息：</p>
<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">nacos</span><span class="pi">:</span>
  <span class="na">config</span><span class="pi">:</span>
    <span class="na">bootstrap</span><span class="pi">:</span>
      <span class="na">enable</span><span class="pi">:</span> <span class="kc">true</span>
      <span class="na">log-enable</span><span class="pi">:</span> <span class="kc">false</span>
    <span class="na">server-addr</span><span class="pi">:</span> <span class="s">xxx</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">yaml</span>
    <span class="na">auto-refresh</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="na">data-ids</span><span class="pi">:</span> <span class="s">my-config.yml</span>
</code></pre></div></div>
<p>确认<code class="language-plaintext highlighter-rouge">auto-refresh</code>配置为<code class="language-plaintext highlighter-rouge">true</code>，Nacos提供了注解<code class="language-plaintext highlighter-rouge">@NacosConfigListener</code>可以监听配置修改的信息，排查nacos与client的长连接通道是否正常。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NacosConfigListener</span><span class="o">(</span><span class="n">dataId</span> <span class="o">=</span> <span class="s">"${nacos.config.data-ids}"</span><span class="o">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onConfigChange</span><span class="o">(</span><span class="nc">String</span> <span class="n">newConfig</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Nacos配置更新完成, config data={}"</span><span class="o">,</span> <span class="n">newConfig</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>在控制台修改配置，发现onConfigChange()可以正常触发，说明长连通道没有问题，看来只能追查源码。</p>

<p><code class="language-plaintext highlighter-rouge">com.alibaba.nacos.client.config.impl.CacheData#safeNotifyListener</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">safeNotifyListener</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">dataId</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">group</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">content</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">type</span><span class="o">,</span>
            <span class="kd">final</span> <span class="nc">String</span> <span class="n">md5</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">encryptedDataKey</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">ManagerListenerWrap</span> <span class="n">listenerWrap</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">Listener</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">listenerWrap</span><span class="o">.</span><span class="na">listener</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">listenerWrap</span><span class="o">.</span><span class="na">inNotifying</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">LOGGER</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span>
                    <span class="s">"[{}] [notify-currentSkip] dataId={}, group={}, md5={}, listener={}, listener is not finish yet,will try next time."</span><span class="o">,</span>
                    <span class="n">name</span><span class="o">,</span> <span class="n">dataId</span><span class="o">,</span> <span class="n">group</span><span class="o">,</span> <span class="n">md5</span><span class="o">,</span> <span class="n">listener</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Runnable</span> <span class="n">job</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
            <span class="nc">ClassLoader</span> <span class="n">myClassLoader</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">();</span>
            <span class="nc">ClassLoader</span> <span class="n">appClassLoader</span> <span class="o">=</span> <span class="n">listener</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">listener</span> <span class="k">instanceof</span> <span class="nc">AbstractSharedListener</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">AbstractSharedListener</span> <span class="n">adapter</span> <span class="o">=</span> <span class="o">(</span><span class="nc">AbstractSharedListener</span><span class="o">)</span> <span class="n">listener</span><span class="o">;</span>
                    <span class="n">adapter</span><span class="o">.</span><span class="na">fillContext</span><span class="o">(</span><span class="n">dataId</span><span class="o">,</span> <span class="n">group</span><span class="o">);</span>
                    <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"[{}] [notify-context] dataId={}, group={}, md5={}"</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">dataId</span><span class="o">,</span> <span class="n">group</span><span class="o">,</span> <span class="n">md5</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">// Before executing the callback, set the thread classloader to the classloader of</span>
                <span class="c1">// the specific webapp to avoid exceptions or misuses when calling the spi interface in</span>
                <span class="c1">// the callback method (this problem occurs only in multi-application deployment).</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">setContextClassLoader</span><span class="o">(</span><span class="n">appClassLoader</span><span class="o">);</span>
                
                <span class="nc">ConfigResponse</span> <span class="n">cr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConfigResponse</span><span class="o">();</span>
                <span class="n">cr</span><span class="o">.</span><span class="na">setDataId</span><span class="o">(</span><span class="n">dataId</span><span class="o">);</span>
                <span class="n">cr</span><span class="o">.</span><span class="na">setGroup</span><span class="o">(</span><span class="n">group</span><span class="o">);</span>
                <span class="n">cr</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="n">content</span><span class="o">);</span>
                <span class="n">cr</span><span class="o">.</span><span class="na">setEncryptedDataKey</span><span class="o">(</span><span class="n">encryptedDataKey</span><span class="o">);</span>
                <span class="n">configFilterChainManager</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">cr</span><span class="o">);</span>
                <span class="nc">String</span> <span class="n">contentTmp</span> <span class="o">=</span> <span class="n">cr</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span>
                <span class="n">listenerWrap</span><span class="o">.</span><span class="na">inNotifying</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

                <span class="c1">// 重点实现方法，将Nacos Server的配置写入Spring容器中</span>
                <span class="n">listener</span><span class="o">.</span><span class="na">receiveConfigInfo</span><span class="o">(</span><span class="n">contentTmp</span><span class="o">);</span>
                
                <span class="c1">// compare lastContent and content</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">listener</span> <span class="k">instanceof</span> <span class="nc">AbstractConfigChangeListener</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Map</span> <span class="n">data</span> <span class="o">=</span> <span class="nc">ConfigChangeHandler</span><span class="o">.</span><span class="na">getInstance</span><span class="o">()</span>
                            <span class="o">.</span><span class="na">parseChangeData</span><span class="o">(</span><span class="n">listenerWrap</span><span class="o">.</span><span class="na">lastContent</span><span class="o">,</span> <span class="n">content</span><span class="o">,</span> <span class="n">type</span><span class="o">);</span>
                    <span class="nc">ConfigChangeEvent</span> <span class="n">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConfigChangeEvent</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
                    <span class="o">((</span><span class="nc">AbstractConfigChangeListener</span><span class="o">)</span> <span class="n">listener</span><span class="o">).</span><span class="na">receiveConfigChange</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
                    <span class="n">listenerWrap</span><span class="o">.</span><span class="na">lastContent</span> <span class="o">=</span> <span class="n">content</span><span class="o">;</span>
                <span class="o">}</span>
                
                <span class="o">.....</span><span class="na">省略部分代码</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>进入receiveConfigInfo()实现：
<code class="language-plaintext highlighter-rouge">com.alibaba.nacos.spring.context.event.config.DelegatingEventPublishingListener#receiveConfigInfo</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">receiveConfigInfo</span><span class="o">(</span><span class="nc">String</span> <span class="n">content</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 刷新Spring容器配置</span>
	<span class="n">onReceived</span><span class="o">(</span><span class="n">content</span><span class="o">);</span>
	<span class="c1">// 发布变更事件</span>
	<span class="n">publishEvent</span><span class="o">(</span><span class="n">content</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">com.alibaba.nacos.spring.core.env.NacosPropertySourcePostProcessor#addListenerIfAutoRefreshed</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addListenerIfAutoRefreshed</span><span class="o">(</span>
			<span class="kd">final</span> <span class="nc">NacosPropertySource</span> <span class="n">nacosPropertySource</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Properties</span> <span class="n">properties</span><span class="o">,</span>
			<span class="kd">final</span> <span class="nc">ConfigurableEnvironment</span> <span class="n">environment</span><span class="o">)</span> <span class="o">{</span>

		<span class="k">if</span> <span class="o">(!</span><span class="n">nacosPropertySource</span><span class="o">.</span><span class="na">isAutoRefreshed</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// Disable Auto-Refreshed</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="kd">final</span> <span class="nc">String</span> <span class="n">dataId</span> <span class="o">=</span> <span class="n">nacosPropertySource</span><span class="o">.</span><span class="na">getDataId</span><span class="o">();</span>
		<span class="kd">final</span> <span class="nc">String</span> <span class="n">groupId</span> <span class="o">=</span> <span class="n">nacosPropertySource</span><span class="o">.</span><span class="na">getGroupId</span><span class="o">();</span>
		<span class="kd">final</span> <span class="nc">String</span> <span class="n">type</span> <span class="o">=</span> <span class="n">nacosPropertySource</span><span class="o">.</span><span class="na">getType</span><span class="o">();</span>
		<span class="kd">final</span> <span class="nc">NacosServiceFactory</span> <span class="n">nacosServiceFactory</span> <span class="o">=</span> <span class="n">getNacosServiceFactoryBean</span><span class="o">(</span>
				<span class="n">beanFactory</span><span class="o">);</span>

		<span class="k">try</span> <span class="o">{</span>

			<span class="nc">ConfigService</span> <span class="n">configService</span> <span class="o">=</span> <span class="n">nacosServiceFactory</span>
					<span class="o">.</span><span class="na">createConfigService</span><span class="o">(</span><span class="n">properties</span><span class="o">);</span>

			<span class="nc">Listener</span> <span class="n">listener</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AbstractListener</span><span class="o">()</span> <span class="o">{</span>

				<span class="nd">@Override</span>
				<span class="kd">public</span> <span class="kt">void</span> <span class="nf">receiveConfigInfo</span><span class="o">(</span><span class="nc">String</span> <span class="n">config</span><span class="o">)</span> <span class="o">{</span>
					<span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">nacosPropertySource</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
					<span class="nc">NacosPropertySource</span> <span class="n">newNacosPropertySource</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NacosPropertySource</span><span class="o">(</span>
							<span class="n">dataId</span><span class="o">,</span> <span class="n">groupId</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">config</span><span class="o">,</span> <span class="n">type</span><span class="o">);</span>
					<span class="n">newNacosPropertySource</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">nacosPropertySource</span><span class="o">);</span>
					<span class="nc">MutablePropertySources</span> <span class="n">propertySources</span> <span class="o">=</span> <span class="n">environment</span>
							<span class="o">.</span><span class="na">getPropertySources</span><span class="o">();</span>
					<span class="c1">// replace NacosPropertySource</span>
					<span class="c1">// 核心实现，将Nacos的配置值刷新Spring容器中的配置值</span>
					<span class="n">propertySources</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">newNacosPropertySource</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">};</span>

			<span class="o">....</span><span class="na">省略部分代码</span>
	<span class="o">}</span>
</code></pre></div></div>
<p>点击replace的实现，发现一点问题：
<img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/nacos%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A51.jpeg?raw=true" alt="疑点1" />
这里面有两个实现，其中一个是jasypt的实现，这个三方类库是常用于对代码中的数据库配置信息进行加密的，难道说，是因为它？同时在控制台也有一条日志值得注意：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[notify-error] dataId=xxx  …… placeholder 'project.version' in value &amp;quot;${project.version}
</code></pre></div></div>
<p>这里是一个疑点，我们先继续往下看：
<code class="language-plaintext highlighter-rouge">com.alibaba.nacos.spring.context.event.config.DelegatingEventPublishingListener#receiveConfigInfo</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">receiveConfigInfo</span><span class="o">(</span><span class="nc">String</span> <span class="n">content</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">onReceived</span><span class="o">(</span><span class="n">content</span><span class="o">);</span>
	<span class="n">publishEvent</span><span class="o">(</span><span class="n">content</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">publishEvent</span><span class="o">(</span><span class="nc">String</span> <span class="n">content</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">NacosConfigReceivedEvent</span> <span class="n">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NacosConfigReceivedEvent</span><span class="o">(</span><span class="n">configService</span><span class="o">,</span>
			<span class="n">dataId</span><span class="o">,</span> <span class="n">groupId</span><span class="o">,</span> <span class="n">content</span><span class="o">,</span> <span class="n">configType</span><span class="o">);</span>
	<span class="c1">// 发布变更事件</span>
	<span class="n">applicationEventPublisher</span><span class="o">.</span><span class="na">publishEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">org.springframework.context.support.AbstractApplicationContext#publishEvent</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
	 * Publish the given event to all listeners.
	 * @param event the event to publish (may be an {@link ApplicationEvent}
	 * or a payload object to be turned into a {@link PayloadApplicationEvent})
	 * @param eventType the resolved event type, if known
	 * @since 4.2
	 */</span>
	<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">publishEvent</span><span class="o">(</span><span class="nc">Object</span> <span class="n">event</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">ResolvableType</span> <span class="n">eventType</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">event</span><span class="o">,</span> <span class="s">"Event must not be null"</span><span class="o">);</span>

		<span class="c1">// Decorate event as an ApplicationEvent if necessary</span>
		<span class="nc">ApplicationEvent</span> <span class="n">applicationEvent</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">event</span> <span class="k">instanceof</span> <span class="nc">ApplicationEvent</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">applicationEvent</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ApplicationEvent</span><span class="o">)</span> <span class="n">event</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="n">applicationEvent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PayloadApplicationEvent</span><span class="o">&lt;&gt;(</span><span class="k">this</span><span class="o">,</span> <span class="n">event</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">eventType</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">eventType</span> <span class="o">=</span> <span class="o">((</span><span class="nc">PayloadApplicationEvent</span><span class="o">&lt;?&gt;)</span> <span class="n">applicationEvent</span><span class="o">).</span><span class="na">getResolvableType</span><span class="o">();</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="c1">// Multicast right now if possible - or lazily once the multicaster is initialized</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">earlyApplicationEvents</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">earlyApplicationEvents</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">applicationEvent</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="c1">// 重点关注，发布广播事件，通知全部监听器</span>
			<span class="n">getApplicationEventMulticaster</span><span class="o">().</span><span class="na">multicastEvent</span><span class="o">(</span><span class="n">applicationEvent</span><span class="o">,</span> <span class="n">eventType</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="c1">// Publish event via parent context as well...</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">parent</span> <span class="k">instanceof</span> <span class="nc">AbstractApplicationContext</span><span class="o">)</span> <span class="o">{</span>
				<span class="o">((</span><span class="nc">AbstractApplicationContext</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">parent</span><span class="o">).</span><span class="na">publishEvent</span><span class="o">(</span><span class="n">event</span><span class="o">,</span> <span class="n">eventType</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="k">else</span> <span class="o">{</span>
				<span class="k">this</span><span class="o">.</span><span class="na">parent</span><span class="o">.</span><span class="na">publishEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre></div></div>
<p>下面就是核心的实现部分，真正刷新值的实现逻辑：
<code class="language-plaintext highlighter-rouge">com.alibaba.nacos.spring.context.annotation.config.NacosValueAnnotationBeanPostProcessor#onApplicationEvent</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onApplicationEvent</span><span class="o">(</span><span class="nc">NacosConfigReceivedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// In to this event receiver, the environment has been updated the</span>
	<span class="c1">// latest configuration information, pull directly from the environment</span>
	<span class="c1">// fix issue #142</span>
	<span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NacosValueTarget</span><span class="o">&gt;&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">placeholderNacosValueTargetMap</span>
			<span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
		<span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="na">resolvePlaceholders</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
		<span class="c1">// 从Spring容器中获取变更后的新值，通过反射的方式，更新数据</span>
		<span class="nc">String</span> <span class="n">newValue</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">newValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">continue</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">NacosValueTarget</span><span class="o">&gt;</span> <span class="n">beanPropertyList</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
		<span class="k">for</span> <span class="o">(</span><span class="nc">NacosValueTarget</span> <span class="n">target</span> <span class="o">:</span> <span class="n">beanPropertyList</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">String</span> <span class="n">md5String</span> <span class="o">=</span> <span class="nc">MD5Utils</span><span class="o">.</span><span class="na">md5Hex</span><span class="o">(</span><span class="n">newValue</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
			<span class="kt">boolean</span> <span class="n">isUpdate</span> <span class="o">=</span> <span class="o">!</span><span class="n">target</span><span class="o">.</span><span class="na">lastMD5</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">md5String</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">isUpdate</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">target</span><span class="o">.</span><span class="na">updateLastMD5</span><span class="o">(</span><span class="n">md5String</span><span class="o">);</span>
				<span class="nc">Object</span> <span class="n">evaluatedValue</span> <span class="o">=</span> <span class="n">resolveNotifyValue</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">nacosValueExpr</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">newValue</span><span class="o">);</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">method</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">setField</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">evaluatedValue</span><span class="o">);</span>
				<span class="o">}</span>
				<span class="k">else</span> <span class="o">{</span>
					<span class="n">setMethod</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">evaluatedValue</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>OK，看到这里，基本已经明朗，了解了Nacos配置刷新的全流程，非常可疑的一点，就是三方类库jasypt，为了验证才想，我们将jasypt的类库移除，再次进行尝试，奇迹出现了！Nacos可以顺利刷新配置值，终于破案，是因为jasypt的加密导致的该问题，搜了一下可能导致的原因：
1、属性源优先级冲突：jasypt 的 PropertySource（如 EncryptablePropertySource）可能覆盖或干扰 Nacos 的动态属性源，导致解密后的值无法被 Nacos 更新逻辑捕获。
2、解密逻辑未触发：Nacos 配置更新时，新的加密值未被 jasypt 及时解密，导致 Environment 中仍是旧值。</p>

<p>查看一下jasypt使用的版本：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;dependency&gt;
    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;
    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div></div>
<p>猜想是否是2.1.1版本的BUG导致了该问题，于是升级至最新版本3.0.5，再次进行测试，发现Nacos可以顺利更新，问题解决。</p>]]></content><author><name>GitHub User</name></author><category term="Others" /><category term="Nacos" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">关于Valkey你需要知道的事情</title><link href="http://localhost:4000/redis/2025/04/17/%E5%85%B3%E4%BA%8EValkey%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85.html" rel="alternate" type="text/html" title="关于Valkey你需要知道的事情" /><published>2025-04-17T00:00:00+08:00</published><updated>2025-04-17T00:00:00+08:00</updated><id>http://localhost:4000/redis/2025/04/17/%E5%85%B3%E4%BA%8EValkey%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85</id><content type="html" xml:base="http://localhost:4000/redis/2025/04/17/%E5%85%B3%E4%BA%8EValkey%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85.html"><![CDATA[<p><img src="https://raw.githubusercontent.com/wtopps/wtopps.github.io/refs/heads/master/images/Valkey.webp" alt="banner" /></p>

<h2 id="前言">前言</h2>

<blockquote>
  <p>Valkey is an open source (BSD) high-performance key/value datastore that supports a variety of workloads such as caching, message queues, and can act as a primary database. The project is backed by the Linux Foundation, ensuring it will remain open source forever.</p>
</blockquote>

<p>Valkey 是 Redis 的一个开源分支（fork），由 Linux 基金会支持，于 2024 年 3 月因 Redis 许可证从 BSD 3-clause 转为更严格的源代码可用许可证（RSALv2 和 SSPLv1）而创建。Valkey 基于 Redis 7.2.4 版本，旨在保持开源特性并进一步优化性能和功能。</p>

<p>看到这里你可能满头问号，什么是<strong>BSD 3-clause</strong>协议，什么又是<b>RSALv2 和 SSPLv1</b>协议？</p>

<h2 id="bsd-3-clause-vs-rsalv2--ssplv1">BSD 3-clause VS RSALv2 &amp; SSPLv1</h2>

<h3 id="bsd协议的前世今生">BSD协议的前世今生</h3>

<blockquote>
  <p>BSD许可证（英语：Berkeley Software Distribution license）是自由软件中使用最广泛的许可证之一。BSD就是遵照这个许可证来发布，也因此而得名 BSD许可证。</p>

  <p>BSD包最初所有者是加州大学的董事会，这是由于 BSD 源自加州大学伯克利分校。BSD开始后，BSD许可证得以修正，使得以后许多BSD变种，都采用类似风格的条款。</p>

  <p>跟其他条款相比，从GNU通用公共许可证（GPL）到限制重重的著作权（Copyright），BSD许可证比较宽松，甚至跟公有领域更为接近。事实上，BSD许可证被认为是copycenter（中间著作权），介乎标准的copyright与GPL的copyleft之间。”Take it down to the copy center and make as many copies as you want”[1]。可以说，GPL强迫后续版本必须一样是自由软件，BSD的后续版本可以选择要继续是BSD或其他自由软件条款或封闭软件等等。——Wikipedia</p>
</blockquote>

<p>BSD 3-Clause 许可证（<strong>BSD 3-Clause License</strong>，又称 <strong>Revised BSD License</strong> 或 <strong>New BSD License</strong>）是一种 <strong>高度宽松的开源许可证</strong>，允许用户自由使用、修改和分发代码，几乎没有任何使用限制（包括商业用途）。它是 Berkeley Software Distribution（BSD）操作系统及其衍生软件的传统许可证。</p>

<p><strong>核心条款（3个主要条件）</strong></p>

<p>许可证名称中的 “3-Clause” 指它包含 <strong>3 个基本约束条件</strong>：</p>

<ol>
  <li><strong>保留原始版权声明</strong>（Redistributions must retain the original copyright notice）
    <ul>
      <li>任何分发或修改后的代码必须 <strong>包含原始作者的版权声明</strong>。</li>
    </ul>
  </li>
  <li><strong>保留许可证文本</strong>（Redistributions must include the license text）
    <ul>
      <li>所有副本（无论是二进制还是源代码）必须附带 <strong>完整的 BSD 3-Clause 许可证文本</strong>。</li>
    </ul>
  </li>
  <li><strong>禁止使用作者名进行推广</strong>（Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission）
    <ul>
      <li>不得使用原作者或贡献者的名字 <strong>为衍生作品背书或营销</strong>，除非获得明确书面许可。</li>
    </ul>
  </li>
</ol>

<p>BSD 3-Clause由于极其宽松的限制，允许闭源、商用，无需回报社区，因而受到了商业公司的大力追捧。</p>

<h3 id="rsalv2--ssplv1协议的前世今生">RSALv2 &amp; SSPLv1协议的前世今生</h3>

<p><strong>RSALv2</strong>全称<em>Redis Source Available License</em>，是由Redis公司为主导，核心目标是限制云厂商商业化托管服务因而推出的协议，可以说是专门为了云厂商而制定的协议，RSALv2限制了云厂商（如AWS/Azure）将其作为托管服务商业化提供（需与Redis签订商业协议），但允许其他企业内部使用或开发专有软件。</p>

<p><strong>SSPLv1</strong>全称<em>Redis Source Available License</em>，是由MongoDB为主导，防止SaaS厂商规避开源贡献而制定的协议。</p>

<p>其要求 <strong>任何提供SSPL软件作为服务的行为</strong> 必须开源整个服务栈的代码（包括管理工具、监控系统等），非SaaS场景下可自由使用（如本地部署）。</p>

<p>OK，说了这么多，你可能也看晕了，下面用一张图标来进行一个总结：</p>

<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/License%20Compare.png?raw=true" alt="License" /></p>

<table>
  <thead>
    <tr>
      <th>**义务**</th>
      <th>RSALv2</th>
      <th>SSPLv1</th>
      <th>BSD 3-Clause</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>保留版权声明</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>允许修改/闭源</td>
      <td>✅（非云场景）</td>
      <td>✅（非SaaS场景）</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>云/SaaS触发条款</td>
      <td>❌云托管</td>
      <td>❌SaaS需开源</td>
      <td>无限制</td>
    </tr>
    <tr>
      <td>专利授权</td>
      <td>有（限制性）</td>
      <td>有</td>
      <td>无</td>
    </tr>
  </tbody>
</table>

<p><strong>Redis</strong>自 2024 年 3 月起，采用 RSALv2 和 SSPLv1 许可证，限制了云服务提供商和某些商业场景的自由使用，引发社区不满，导致 Valkey 的诞生。</p>

<h1 id="valkey的优势">Valkey的优势</h1>

<h2 id="与-redis-的兼容性与迁移简便性">与 Redis 的兼容性与迁移简便性</h2>

<p>作为 Redis 7.2.4 的直接分支，Valkey 保留完全兼容性，支持 Redis 的 API、命令和数据结构（如字符串、哈希、列表、集合等）。迁移只需更改连接配置（如 YAML 文件中的一行），无需修改代码。AWS ElastiCache 和 MemoryDB 支持无缝迁移。但是需要注意的是，Redis 提供专有模块（如 RedisBloom、RedisGraph、RedisTimeSeries），Valkey 当前不支持，但社区正在开发替代方案。</p>

<h2 id="性能优化">性能优化</h2>

<h4 id="多线程支持">多线程支持</h4>

<p>Valkey 引入了多线程 I/O 和命令执行，充分利用多核处理器，显著提升写密集型工作负载的吞吐量。Valkey 8.0 发布宣称可达 100 万请求每秒（RPS），比 Redis 开源版本（7.2.4）快 3 倍。</p>

<p>More Detail：https://aws.amazon.com/cn/blogs/china/valkey-performance-testing-exploring-version-changes-and-cloud-hosting-performance-improvements/</p>

<p><img src="https://s3.cn-north-1.amazonaws.com.cn/awschinablog/valkey-performance-testing-exploring-version-changes-and-cloud-hosting-performance-improvements1.jpg" alt="AWS压测对比和分析" /></p>

<h4 id="异步-io">异步 I/O</h4>

<p>Valkey 通过异步 I/O 线程降低延迟，提升实时应用响应速度，优于 Redis 的单线程主导架构。</p>

<p>Valkey 的多线程和异步 I/O 使高吞吐量场景（如实时分析、电商库存更新）表现更优，尤其适合现代硬件。</p>

<h3 id="内存效率">内存效率</h3>

<p><strong>新字典结构</strong>：Valkey 优化了字典结构，减少内存占用，适合大规模数据集场景。</p>

<p><strong>内存密度提升</strong>：Valkey 8.0 通过 AWS 的贡献提高了集群内存密度，优化了内存密集型工作负载。</p>

<p><b>内存管理</b>：Redis 的内存管理较为传统，在大数据集或高并发场景下内存效率较低，Valkey 的内存优化降低运营成本，适合缓存、会话存储等内存敏感应用。</p>

<h3 id="集群监控">集群监控</h3>

<p><strong>每槽指标</strong>：Valkey 提供按槽（per-slot）粒度的性能和使用模式指标，帮助管理员主动识别和解决性能瓶颈。</p>

<p>Redis 的监控功能较为基础，缺乏细粒度指标，难以满足复杂应用的监控需求，Valkey 的高级观测性对需要深入性能分析的场景（如大规模缓存或实时数据处理）有显著优势。</p>

<h3 id="实验性功能rdma-支持">实验性功能：RDMA 支持</h3>

<p>Redis 开源版本不原生支持 RDMA，限制了其在高性能计算场景的应用，而Valkey提供实验性 RDMA（远程直接内存访问）支持，可在特定高性能环境中大幅提升性能。</p>

<p>这里需要简单介绍一下什么是RDMA技术。</p>

<h4 id="传统-redis-的数据处理瓶颈">传统 Redis 的数据处理瓶颈</h4>

<p>典型请求路径（TCP/IP 模式）</p>

<p>当客户端发送一个 <code class="language-plaintext highlighter-rouge">GET key</code> 请求时，Redis Server 端的处理流程如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 网卡接收 TCP 报文 → 内核协议栈（TCP/IP 解包）→ 数据拷贝到内核缓冲区
2. 内核通过系统调用（read()）将数据拷到用户态（Redis 进程）
3. Redis 主线程解析命令（如识别 "GET"）
4. 从内存哈希表中查找 `key` 对应的值
5. 反向重复上述步骤：用户态 → 内核 → 网卡 → 客户端
</code></pre></div></div>

<p><strong>关键瓶颈</strong>：</p>

<ul>
  <li><strong>数据拷贝</strong>：至少 2 次内核态↔用户态拷贝（即使使用零拷贝技术如 <code class="language-plaintext highlighter-rouge">sendfile</code>，命令解析仍需用户态介入）。</li>
  <li><strong>CPU 开销</strong>：协议栈处理（校验和、序列号等）占大量 CPU 周期（尤其在 10Gbps+ 高带宽场景）。</li>
</ul>

<h4 id="valkey-的-rdma-如何绕过这些瓶颈">Valkey 的 RDMA 如何绕过这些瓶颈？</h4>

<p><strong>RDMA 的 Server 端角色</strong></p>

<p>RDMA 在 Valkey Server 端的核心创新是：
 <strong>将内存中的键值数据直接暴露给网卡</strong>，客户端可通过 RDMA 协议 <strong>直接读取或修改 Server 内存</strong>，无需经过传统内核协议栈和 Redis 主线程的解析。</p>

<p><strong>具体绕过机制</strong></p>

<p>以 <code class="language-plaintext highlighter-rouge">GET key</code> 为例，RDMA 模式下的流程：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 客户端预先与 Server 协商好：
   - Key 的内存地址（通过注册的 Memory Region）
   - 权限（只读/读写）
   
2. 客户端网卡直接发起 RDMA READ 操作：
   - 通过 RoCE/InfiniBand 协议包，指定目标地址（Server 内存中 `key` 的位置）
   - 数据从 Server 内存 → 客户端内存，全程无需 Server 的 CPU 参与

3. Server 的 RDMA 网卡自主完成数据传输：
   - 校验权限和地址合法性（通过保护域 Protection Domain）
   - 直接访问内存数据并返回
</code></pre></div></div>

<p><strong>关键突破</strong>：</p>

<ul>
  <li><strong>零拷贝</strong>：数据不经过内核，也不触发 Server 的 CPU 中断。</li>
  <li><strong>零解析</strong>：客户端需提前知道 Key 的内存布局（依赖预注册的元数据），跳过命令解析步骤。</li>
</ul>

<table>
  <thead>
    <tr>
      <th>**步骤**</th>
      <th>**TCP/IP 模式**</th>
      <th>**RDMA 模式**</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>网络协议处理</td>
      <td>内核 TCP/IP 栈</td>
      <td>网卡硬件处理（RoCE/IB）</td>
    </tr>
    <tr>
      <td>数据处理线程</td>
      <td>Redis 主线程参与</td>
      <td>无 CPU 参与（完全网卡卸载）</td>
    </tr>
    <tr>
      <td>数据路径</td>
      <td>用户态 ↔ 内核态多次拷贝</td>
      <td>网卡 ↔ 内存直通</td>
    </tr>
    <tr>
      <td>延迟分布</td>
      <td>毫秒级（CPU 调度抖动）</td>
      <td>微秒级（硬件确定性强）</td>
    </tr>
  </tbody>
</table>

<h4 id="rdma目前的限制">RDMA目前的限制</h4>

<ol>
  <li>仅支持简单 KV 操作
    <ul>
      <li><code class="language-plaintext highlighter-rouge">GET/SET</code> 可直接映射为 RDMA READ/WRITE。</li>
      <li>复杂命令（如 <code class="language-plaintext highlighter-rouge">INCR</code>、<code class="language-plaintext highlighter-rouge">LPUSH</code>）仍需走 TCP 路径（需 CPU 执行逻辑）。</li>
    </ul>
  </li>
  <li>客户端需改造
    <ul>
      <li>传统 Redis 客户端无法直接使用，需集成 RDMA 库（如 <code class="language-plaintext highlighter-rouge">libibverbs</code>）。</li>
    </ul>
  </li>
  <li>安全边界模糊
    <ul>
      <li>Server 内存直接暴露给客户端，依赖网络隔离和硬件校验（如 P_Key）。</li>
    </ul>
  </li>
  <li>网卡支持
    <ul>
      <li>必须使用支持的RDMA 网卡</li>
    </ul>
  </li>
</ol>

<h3 id="社区的支持">社区的支持</h3>

<p><strong>Valkey</strong>由 Linux 基金会托管，得到 AWS、Google Cloud、Oracle、Snap Inc. 等公司支持，贡献者包括 Redis 原核心开发者（如 Madelyn Olson 和 Binbin Zhu）。Valkey 8.1（2025 年 4 月发布）显示出快速迭代能力，性能提升 10%，TLS 连接管理更高效。</p>

<p><strong>Redis</strong> 由Redis公司进行维护，商业支持强大，但社区贡献受限，核心开发主要由公司控制。 Valkey 的社区驱动模式和广泛行业支持确保长期开发活力和快速功能迭代，降低对单一厂商的依赖。</p>

<p>综上，我们简单总结一下Valkey：</p>

<ol>
  <li>完全开源的 BSD 许可证，得到广泛行业支持。</li>
  <li>多线程、异步 I/O 和内存优化带来显著性能提升（最高 100 万 RPS）。</li>
  <li>改进的集群管理（自动故障转移、可靠槽迁移）。</li>
  <li>细粒度观测性和实验性 RDMA 支持。</li>
  <li>与 Redis 的高兼容性，迁移成本低。</li>
</ol>

<h2 id="结语">结语</h2>

<p>Redis经过多年的发展，在互联网行业内的地位牢不可破，但Valkey作为社区的新宠儿，在多家云厂商的推崇下，发展前景也是非常的可期，不过真的要在生产环境将Redis替换为Valkey，还有待验证，我们可以持续观望社区的动态。</p>]]></content><author><name>GitHub User</name></author><category term="Redis" /><category term="Redis" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">CompletableFuture你需要知道的事情.</title><link href="http://localhost:4000/java/2025/03/26/CompletableFuture%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85.html" rel="alternate" type="text/html" title="CompletableFuture你需要知道的事情." /><published>2025-03-26T00:00:00+08:00</published><updated>2025-03-26T00:00:00+08:00</updated><id>http://localhost:4000/java/2025/03/26/CompletableFuture%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85</id><content type="html" xml:base="http://localhost:4000/java/2025/03/26/CompletableFuture%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85.html"><![CDATA[<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/CompletableFuture.jpeg?raw=true" alt="banner" /></p>

<h1 id="问题">问题</h1>

<p>面试官：请使用多线程分别打印“Hello World”，当全部线程执行完成后，打印“Finish”。</p>

<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/please%20show%20yourself.jpeg?raw=true" alt="please show yourself" /></p>

<p>这是一道非常经典的面试题，Java的面试中高频出现，主要考察多线程的使用和join()的应用，我们来尝试实现一下：</p>

<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/%E9%9C%B2%E4%B8%80%E6%89%8B.jpg?raw=true" alt="露一手" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadJoinDemo</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">threadA</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">threadB</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
        <span class="n">threadA</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"threadA"</span><span class="o">);</span>
        <span class="n">threadB</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"threadB"</span><span class="o">);</span>
        <span class="n">threadA</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">threadB</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">threadA</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">threadB</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Finish"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>输出结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello World
Hello World
Finish
</code></pre></div></div>

<p>面试官：小伙子不错，你还有没有更优雅的实现方式？</p>

<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/%E8%BF%99%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%9C%89.png?raw=true" alt="这个可以有" /></p>

<h1 id="completablefuture">CompletableFuture</h1>

<h2 id="一概述">一、概述</h2>

<p>CompletableFuture 是 Java 8 引入的一个强大的异步编程工具，它实现了 Future 和 CompletionStage 接口，提供了丰富的异步操作和组合能力。相比传统的 Future，CompletableFuture 具有以下优势：</p>

<ol>
  <li>支持显式完成（手动设置结果）</li>
  <li>提供丰富的回调机制</li>
  <li>支持链式调用和组合操作</li>
  <li>内置异常处理机制</li>
  <li>支持多个 CompletableFuture 的组合</li>
</ol>

<p>回到上面的问题，如果使用CompletableFuture如何实现？</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">runAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World"</span><span class="o">)),</span>
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">runAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World"</span><span class="o">))</span>
<span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span><span class="n">futures</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">[</span><span class="mi">0</span><span class="o">])).</span><span class="na">join</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Finish"</span><span class="o">));</span>
</code></pre></div></div>

<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/%E4%BC%98%E9%9B%85.gif?raw=true" alt="优雅" /></p>

<p>下面我们来一起了解一下CompletableFuture的细节。</p>

<h2 id="二核心实现细节">二、核心实现细节</h2>

<h3 id="1-基本结构">1. 基本结构</h3>

<p>CompletableFuture 的核心字段包括：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>volatile Object result;       // 结果或异常的包装
volatile Completion stack;    // 依赖此 Future 的操作栈
</code></pre></div></div>

<h3 id="2-完成机制">2. 完成机制</h3>

<p>CompletableFuture 可以通过以下方式完成：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">complete(T value)</code>：正常完成</li>
  <li><code class="language-plaintext highlighter-rouge">completeExceptionally(Throwable ex)</code>：异常完成</li>
  <li><code class="language-plaintext highlighter-rouge">cancel(boolean mayInterruptIfRunning)</code>：取消任务</li>
</ul>

<h3 id="3-依赖关系管理">3. 依赖关系管理</h3>

<p>CompletableFuture 使用 <code class="language-plaintext highlighter-rouge">Completion</code> 链表来管理依赖关系。当一个 CompletableFuture 完成时，它会触发所有依赖它的操作。</p>

<h3 id="4-线程池使用">4. 线程池使用</h3>

<p>默认情况下，CompletableFuture 使用 <code class="language-plaintext highlighter-rouge">ForkJoinPool.commonPool()</code> 作为异步执行的线程池。可以通过提供自定义的 <code class="language-plaintext highlighter-rouge">Executor</code> 来改变这一行为。</p>

<h2 id="三核心-api-和使用技巧">三、核心 API 和使用技巧</h2>

<h3 id="1-创建-completablefuture">1. 创建 CompletableFuture</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 使用静态工厂方法创建已完成的 Future</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">completedFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">completedFuture</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>

<span class="c1">// 2. 创建异步任务</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">runAsyncFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">runAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// 无返回值的异步任务</span>
<span class="o">});</span>

<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">supplyAsyncFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// 有返回值的异步任务</span>
    <span class="k">return</span> <span class="s">"Result"</span><span class="o">;</span>
<span class="o">});</span>

<span class="c1">// 3. 使用自定义线程池</span>
<span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">customExecutorFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">"Result with custom executor"</span><span class="o">;</span>
<span class="o">},</span> <span class="n">executor</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="2-结果处理和转换">2. 结果处理和转换</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// thenApply - 同步转换结果</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"Hello"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" World"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">);</span>

<span class="c1">// thenApplyAsync - 异步转换结果</span>
<span class="n">future</span><span class="o">.</span><span class="na">thenApplyAsync</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">);</span>

<span class="c1">// thenAccept - 消费结果但不返回新值</span>
<span class="n">future</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

<span class="c1">// thenRun - 不消费结果，只执行操作</span>
<span class="n">future</span><span class="o">.</span><span class="na">thenRun</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Operation completed"</span><span class="o">));</span>
</code></pre></div></div>

<h3 id="3-组合多个-future">3. 组合多个 Future</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// thenCompose - 扁平化 Future</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"Hello"</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="n">future1</span><span class="o">.</span><span class="na">thenCompose</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> 
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" World"</span><span class="o">));</span>

<span class="c1">// thenCombine - 合并两个独立 Future 的结果</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future3</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"Hello"</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future4</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"World"</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">combined</span> <span class="o">=</span> <span class="n">future3</span><span class="o">.</span><span class="na">thenCombine</span><span class="o">(</span><span class="n">future4</span><span class="o">,</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>

<span class="c1">// allOf - 等待所有 Future 完成</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">all</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span><span class="n">future1</span><span class="o">,</span> <span class="n">future2</span><span class="o">,</span> <span class="n">future3</span><span class="o">);</span>

<span class="c1">// anyOf - 等待任意一个 Future 完成</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">any</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">anyOf</span><span class="o">(</span><span class="n">future1</span><span class="o">,</span> <span class="n">future2</span><span class="o">,</span> <span class="n">future3</span><span class="o">);</span>
</code></pre></div></div>

<p>关于allOf()方法，有一点需要注意，allOf()方法的注释是这样描述的：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Returns a new CompletableFuture that is completed when all of the given CompletableFutures complete. If any of the given CompletableFutures complete exceptionally, then the returned CompletableFuture also does so, with a CompletionException holding this exception as its cause. Otherwise, the results, if any, of the given CompletableFutures are not reflected in the returned CompletableFuture, but may be obtained by inspecting them individually. If no CompletableFutures are provided, returns a CompletableFuture completed with the value null.
</code></pre></div></div>

<p>看完第一句话，可能会理解为，哦这个方法是等待所有的Future完成后，才返回结果呀，其实非也。</p>

<p>这句注释需要仔细理解：</p>

<p><strong>“Returns a new CompletableFuture that is completed when all of the given CompletableFutures complete”</strong></p>

<p>关键在于：</p>

<ol>
  <li>“Returns a new CompletableFuture” - 立即返回一个新的Future对象</li>
  <li>“is completed when…” - 这个新Future在所有子Future完成时才会完成</li>
</ol>

<p>可以做一个实验进行验证：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建几个任务</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"Task 1"</span><span class="o">;</span>
<span class="o">});</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"Task 2"</span><span class="o">;</span>
<span class="o">});</span>

<span class="c1">// allOf返回的新Future</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">allFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span><span class="n">future1</span><span class="o">,</span> <span class="n">future2</span><span class="o">);</span>
<span class="c1">// 这行代码立即返回，不会等待</span>

<span class="c1">// 新Future的状态</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Is completed: "</span> <span class="o">+</span> <span class="n">allFuture</span><span class="o">.</span><span class="na">isDone</span><span class="o">());</span>  <span class="c1">// false</span>
<span class="c1">// 等待2秒后</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Is completed: "</span> <span class="o">+</span> <span class="n">allFuture</span><span class="o">.</span><span class="na">isDone</span><span class="o">());</span>  <span class="c1">// true</span>
</code></pre></div></div>

<p>如果你希望全部的Future执行完成之前，主线程进行阻塞等待结果，你需要这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">all</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span><span class="n">future1</span><span class="o">,</span> <span class="n">future2</span><span class="o">,</span> <span class="n">future3</span><span class="o">);</span>
<span class="n">all</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="4-异常处理">4. 异常处理</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Error"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="s">"Success"</span><span class="o">;</span>
<span class="o">})</span>
<span class="o">.</span><span class="na">exceptionally</span><span class="o">(</span><span class="n">ex</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Exception: "</span> <span class="o">+</span> <span class="n">ex</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
    <span class="k">return</span> <span class="s">"Recovered"</span><span class="o">;</span>
<span class="o">})</span>
<span class="o">.</span><span class="na">handle</span><span class="o">((</span><span class="n">result</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ex</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Handled error: "</span> <span class="o">+</span> <span class="n">ex</span><span class="o">.</span><span class="na">getMessage</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="s">"Handled result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">;</span>
<span class="o">});</span>
</code></pre></div></div>

<h3 id="5-完成控制">5. 完成控制</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">&lt;&gt;();</span>

<span class="c1">// 手动完成</span>
<span class="n">future</span><span class="o">.</span><span class="na">complete</span><span class="o">(</span><span class="s">"Manual completion"</span><span class="o">);</span>

<span class="c1">// 手动异常完成</span>
<span class="n">future</span><span class="o">.</span><span class="na">completeExceptionally</span><span class="o">(</span><span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">"Failed"</span><span class="o">));</span>

<span class="c1">// 超时完成</span>
<span class="n">future</span><span class="o">.</span><span class="na">completeOnTimeout</span><span class="o">(</span><span class="s">"Default"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>

<span class="c1">// 或超时</span>
<span class="n">future</span><span class="o">.</span><span class="na">orTimeout</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
</code></pre></div></div>

<h2 id="四高级使用技巧">四、高级使用技巧</h2>

<h3 id="1-流水线模式">1. 流水线模式</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">fetchData</span><span class="o">())</span>
    <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">processData</span><span class="o">(</span><span class="n">data</span><span class="o">))</span>
    <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">processedData</span> <span class="o">-&gt;</span> <span class="n">storeData</span><span class="o">(</span><span class="n">processedData</span><span class="o">))</span>
    <span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="n">storedId</span> <span class="o">-&gt;</span> <span class="n">logSuccess</span><span class="o">(</span><span class="n">storedId</span><span class="o">))</span>
    <span class="o">.</span><span class="na">exceptionally</span><span class="o">(</span><span class="n">ex</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">logError</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">});</span>
</code></pre></div></div>

<h3 id="2-异步超时控制">2. 异步超时控制</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">withTimeout</span><span class="o">(</span><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">,</span> 
        <span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">,</span> <span class="no">T</span> <span class="n">defaultValue</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">future</span><span class="o">.</span><span class="na">applyToEither</span><span class="o">(</span>
        <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">defaultValue</span><span class="o">)</span>
            <span class="o">.</span><span class="na">completeOnTimeout</span><span class="o">(</span><span class="n">defaultValue</span><span class="o">,</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">unit</span><span class="o">),</span>
        <span class="nc">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">()</span>
    <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-批量操作">3. 批量操作</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="o">=</span> <span class="n">urls</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">url</span> <span class="o">-&gt;</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">fetchUrl</span><span class="o">(</span><span class="n">url</span><span class="o">)))</span>
    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">allDone</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span><span class="n">futures</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>

<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">allResults</span> <span class="o">=</span> <span class="n">allDone</span><span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span> 
    <span class="n">futures</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">CompletableFuture:</span><span class="o">:</span><span class="n">join</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">()));</span>
</code></pre></div></div>

<h3 id="4-取消传播">4. 取消传播</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"Result"</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>

<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="n">future1</span><span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" processed"</span><span class="o">);</span>

<span class="c1">// 取消第一个 future 会导致依赖它的 future 也被取消</span>
<span class="n">future1</span><span class="o">.</span><span class="na">cancel</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</code></pre></div></div>

<h2 id="五性能优化和注意事项">五、性能优化和注意事项</h2>

<ol>
  <li><strong>线程池选择</strong>：根据任务类型选择合适的线程池
    <ul>
      <li>CPU密集型：使用有界线程池（如 <code class="language-plaintext highlighter-rouge">Executors.newFixedThreadPool</code>）</li>
      <li>IO密集型：使用无界线程池（如 <code class="language-plaintext highlighter-rouge">Executors.newCachedThreadPool</code>）</li>
    </ul>
  </li>
  <li><strong>避免阻塞</strong>：不要在回调中进行阻塞操作</li>
  <li><strong>合理使用异步</strong>：并非所有操作都需要异步，简单的转换可以直接用同步方法</li>
  <li><strong>资源清理</strong>：长时间运行的 CompletableFuture 链可能会持有资源，需要适当清理</li>
  <li><strong>异常处理</strong>：确保所有可能的异常路径都被处理</li>
  <li><strong>避免嵌套过深</strong>：过深的 CompletableFuture 链会影响可读性</li>
</ol>

<h2 id="六常见问题解决方案">六、常见问题解决方案</h2>

<h3 id="1-如何获取多个-future-的结果">1. 如何获取多个 Future 的结果？</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="o">=</span> <span class="o">...;</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">allFutures</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span>
    <span class="n">futures</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>

<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">allResults</span> <span class="o">=</span> <span class="n">allFutures</span><span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span>
    <span class="n">futures</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">CompletableFuture:</span><span class="o">:</span><span class="n">join</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">()));</span>


<span class="c1">// 使用CompletableFuture并行处理图片上传</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">JSONObject</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">imageInfo</span> <span class="o">-&gt;</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">uploadCorePic</span><span class="o">();</span>
        <span class="o">}))</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

<span class="c1">// 等待所有图片上传完成</span>
<span class="nc">JSONArray</span> <span class="n">picArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JSONArray</span><span class="o">();</span>
<span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span><span class="n">futures</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">[</span><span class="mi">0</span><span class="o">])).</span><span class="na">join</span><span class="o">();</span>
<span class="n">futures</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">CompletableFuture:</span><span class="o">:</span><span class="n">join</span><span class="o">)</span>
        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="nl">Objects:</span><span class="o">:</span><span class="n">nonNull</span><span class="o">)</span>
        <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nl">picArray:</span><span class="o">:</span><span class="n">add</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="2-如何实现重试机制">2. 如何实现重试机制？</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">retry</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">task</span><span class="o">,</span> 
        <span class="kt">int</span> <span class="n">maxRetries</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delay</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxRetries</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">exceptionally</span><span class="o">(</span><span class="n">ex</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">unit</span><span class="o">.</span><span class="na">toMillis</span><span class="o">(</span><span class="n">delay</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">join</span><span class="o">();</span>
        <span class="o">});</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">future</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-如何实现优雅的超时回退">3. 如何实现优雅的超时回退？</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">withFallback</span><span class="o">(</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">,</span> <span class="c1">// 原始任务</span>
        <span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">,</span> <span class="c1">// 超时时间及其时间单位</span>
        <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">fallback</span><span class="o">)</span> <span class="o">{</span>			 <span class="c1">// 降级逻辑</span>
    <span class="kd">final</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">timeoutFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">unit</span><span class="o">.</span><span class="na">toMillis</span><span class="o">(</span><span class="n">timeout</span><span class="o">));</span>
            <span class="k">return</span> <span class="n">fallback</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">fallback</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="k">return</span> <span class="n">future</span><span class="o">.</span><span class="na">applyToEither</span><span class="o">(</span><span class="n">timeoutFuture</span><span class="o">,</span> <span class="nc">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个可能耗时的任务</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span>  <span class="c1">// 模拟耗时操作</span>
        <span class="k">return</span> <span class="s">"任务正常完成"</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"被中断"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>

<span class="c1">// 使用withFallback添加3秒超时</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">withTimeout</span> <span class="o">=</span> <span class="n">withFallback</span><span class="o">(</span>
    <span class="n">future</span><span class="o">,</span>
    <span class="mi">3</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
    <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"任务超时，返回降级结果"</span>
<span class="o">);</span>

<span class="c1">// 获取结果</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">withTimeout</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>  <span class="c1">// 会打印"任务超时，返回降级结果"</span>

</code></pre></div></div>

<p>执行示意图：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>原始任务 future     ----5秒-----&gt; "任务正常完成"
                            \
                             \-- 采用先完成的结果
                            /
超时任务 timeoutFuture ----3秒-----&gt; "降级结果"
</code></pre></div></div>

<h2 id="七总结">七、总结</h2>

<p>CompletableFuture 是 Java 异步编程的强大工具，通过合理使用可以构建高效、清晰的异步代码。掌握其核心概念、API 和最佳实践，可以帮助开发者编写更健壮、更易维护的并发应用程序。在实际使用中，应根据具体场景选择合适的组合方式，并注意资源管理和异常处理。</p>]]></content><author><name>GitHub User</name></author><category term="Java" /><category term="Java" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">SQL小菜之TOP N查找问题.</title><link href="http://localhost:4000/mysql/2025/03/17/SQL%E5%B0%8F%E8%8F%9C%E4%B9%8BTOP-N%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98.html" rel="alternate" type="text/html" title="SQL小菜之TOP N查找问题." /><published>2025-03-17T00:00:00+08:00</published><updated>2025-03-17T00:00:00+08:00</updated><id>http://localhost:4000/mysql/2025/03/17/SQL%E5%B0%8F%E8%8F%9C%E4%B9%8BTOP%20N%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98</id><content type="html" xml:base="http://localhost:4000/mysql/2025/03/17/SQL%E5%B0%8F%E8%8F%9C%E4%B9%8BTOP-N%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98.html"><![CDATA[<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/MySQL%20Skill.jpeg?raw=true" alt="banner" /></p>

<h1 id="前言">前言</h1>

<p>SQL的编写是后端面试中非常常见，其中TOP N查找问题也是高频出现的问题，今天我们来看两道SQL TOPN问题。</p>

<h1 id="问题">问题</h1>

<p>我们有一张雇员表Employee：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`Employee`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="nb">int</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`salary`</span> <span class="nb">int</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`department`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="k">COLLATE</span><span class="o">=</span><span class="n">utf8mb4_0900_ai_ci</span>
</code></pre></div></div>

<p>Question1：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">查询并返回</span> <span class="n">Employee</span> <span class="err">表中第二高的</span> <span class="err">不同</span> <span class="err">薪水</span> <span class="err">。如果不存在第二高的薪水，</span>
<span class="err">查询应该返回</span> <span class="k">null</span><span class="err">。</span>

<span class="err">查询结果如下例所示。</span>

<span class="err">示例</span><span class="mi">1</span><span class="err">：</span>
<span class="err">输入：</span>
<span class="n">Employee</span> <span class="err">表：</span>
<span class="o">+</span><span class="c1">----+--------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">salary</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+--------+</span>
<span class="o">|</span> <span class="mi">1</span>  <span class="o">|</span> <span class="mi">100</span>    <span class="o">|</span>
<span class="o">|</span> <span class="mi">2</span>  <span class="o">|</span> <span class="mi">200</span>    <span class="o">|</span>
<span class="o">|</span> <span class="mi">3</span>  <span class="o">|</span> <span class="mi">300</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+--------+</span>
<span class="err">输出：</span>
<span class="o">+</span><span class="c1">---------------------+</span>
<span class="o">|</span> <span class="n">SecondHighestSalary</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">---------------------+</span>
<span class="o">|</span> <span class="mi">200</span>                 <span class="o">|</span>
<span class="o">+</span><span class="c1">---------------------+</span>

<span class="err">示例</span><span class="mi">2</span><span class="err">：</span>
<span class="err">输入：</span>
<span class="n">Employee</span> <span class="err">表：</span>
<span class="o">+</span><span class="c1">----+--------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">salary</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+--------+</span>
<span class="o">|</span> <span class="mi">1</span>  <span class="o">|</span> <span class="mi">100</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+--------+</span>
<span class="err">输出：</span>
<span class="o">+</span><span class="c1">---------------------+</span>
<span class="o">|</span> <span class="n">SecondHighestSalary</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">---------------------+</span>
<span class="o">|</span> <span class="k">null</span>                <span class="o">|</span>
<span class="o">+</span><span class="c1">---------------------+</span>
</code></pre></div></div>

<p>这就是最典型一道TOP N查找问题，本题要求我们查找第二高薪水的记录，我们来将问题进行拆解：</p>

<p>如果要查找第二高的记录，那是不是找到第一高的记录，然后在小于该记录的结果集中，找到最大的那一个，就是我们想要的结果。</p>

<p>OK，思路明确，开始写SQL，先找到第一高那条记录：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">max</span><span class="p">(</span><span class="k">distinct</span><span class="p">(</span><span class="n">salary</span><span class="p">))</span> <span class="k">from</span> <span class="n">Employee</span>
</code></pre></div></div>

<p>因为题干中没有强调记录不重复，因此需要进行去重，接下来第二步，从比它小的结果集中找到最大的那个，就是我们想要的答案：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">max</span><span class="p">(</span><span class="k">distinct</span><span class="p">(</span><span class="n">salary</span><span class="p">))</span> <span class="k">from</span> <span class="n">Employee</span> 
<span class="k">where</span> <span class="n">salary</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">select</span> <span class="k">max</span><span class="p">(</span><span class="k">distinct</span><span class="p">(</span><span class="n">salary</span><span class="p">))</span> <span class="k">from</span> <span class="n">Employee</span><span class="p">)</span>
</code></pre></div></div>

<p>我们同时要考虑一些异常的情况，例如表中如果仅有一条记录，那么结果需要输出null：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">ifNull</span><span class="p">((</span><span class="k">max</span><span class="p">(</span><span class="k">distinct</span><span class="p">(</span><span class="n">salary</span><span class="p">))),</span> <span class="k">null</span><span class="p">)</span> <span class="k">as</span> <span class="s1">'SecondHighestSalary'</span> <span class="k">from</span> <span class="n">Employee</span> 
<span class="k">where</span> <span class="n">salary</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">select</span> <span class="k">max</span><span class="p">(</span><span class="k">distinct</span><span class="p">(</span><span class="n">salary</span><span class="p">))</span> <span class="k">from</span> <span class="n">Employee</span><span class="p">);</span>
</code></pre></div></div>

<p>针对这道题，这个SQL可以解决问题，那么题目换一下，如果不是找第二高的记录呢？如果找第三高，怎么办？</p>

<p>上面的SQL就不能满足我们的需求了，换一个思路，如果要找第N高的记录，我们是不是可以对结果集进行排序，然后把前面的记录丢弃，剩下的结果集取第一个，就是我们想要的结果了？诶？这不就是limit offset么？</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">ifNull</span><span class="p">(</span>
  <span class="p">(</span><span class="k">select</span> <span class="k">distinct</span><span class="p">(</span><span class="n">salary</span><span class="p">)</span> <span class="k">from</span> <span class="n">Employee</span> <span class="k">order</span> <span class="k">by</span> <span class="n">salary</span> <span class="k">desc</span> <span class="k">limit</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="k">null</span><span class="p">)</span> 
<span class="k">as</span> <span class="n">SecondHighestSalary</span><span class="p">;</span>
</code></pre></div></div>

<p>使用limit offset的方式，可以解决大部分简单的TOP N问题了，那么如果修改一下题目，再加入部门的维度，希望找到每个部门中，薪水第二高的记录，上面的解法，似乎就没有办法做到了，那么是否还有其他的解决方法呢？</p>

<p>MySQL在8.0版本中加入了<code class="language-plaintext highlighter-rouge">窗口函数</code>，专门为了解决排行问题，来看一下dense_rank()的使用语法：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DENSE_RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span>
    <span class="p">[</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span><span class="p">,</span> <span class="p">...]</span>
    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">column1</span> <span class="p">[</span><span class="k">ASC</span><span class="o">|</span><span class="k">DESC</span><span class="p">],</span> <span class="n">column2</span> <span class="p">[</span><span class="k">ASC</span><span class="o">|</span><span class="k">DESC</span><span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<p>看起来有点乱哈，没关系，我们来看个示例来帮你理解dense_rank()。</p>

<p>上面的问题，如果用dense_rank()解决：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">(</span>
	<span class="k">select</span> <span class="k">distinct</span> <span class="n">salary</span> <span class="k">from</span> <span class="p">(</span>
    	<span class="k">select</span> <span class="n">dense_rank</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span> <span class="k">order</span> <span class="k">by</span> <span class="n">salary</span> <span class="k">desc</span><span class="p">)</span> <span class="k">as</span> <span class="n">rn</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">Employee</span> <span class="n">u</span>
    <span class="p">)</span> <span class="n">t</span> <span class="k">where</span> <span class="n">t</span><span class="p">.</span><span class="n">rn</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="n">SecondHighestSalary</span><span class="p">;</span>
</code></pre></div></div>

<p>单看上面的SQL你可能还是会一脸懵逼，没关系，让我们来拆解一下SQL，先看最中间的核心子查询：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">dense_rank</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span> <span class="k">order</span> <span class="k">by</span> <span class="n">salary</span> <span class="k">desc</span><span class="p">)</span> <span class="k">as</span> <span class="n">rn</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">Employee</span> <span class="n">u</span><span class="p">;</span>

<span class="o">+</span><span class="c1">----+------+--------+------------+</span>
<span class="o">|</span> <span class="n">rn</span> <span class="o">|</span> <span class="n">id</span>   <span class="o">|</span> <span class="n">salary</span> <span class="o">|</span> <span class="n">department</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+--------+------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>    <span class="mi">4</span> <span class="o">|</span>    <span class="mi">400</span> <span class="o">|</span> <span class="err">二部</span>       <span class="o">|</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span>    <span class="mi">3</span> <span class="o">|</span>    <span class="mi">300</span> <span class="o">|</span> <span class="err">二部</span>       <span class="o">|</span>
<span class="o">|</span>  <span class="mi">3</span> <span class="o">|</span>    <span class="mi">2</span> <span class="o">|</span>    <span class="mi">200</span> <span class="o">|</span> <span class="err">一部</span>       <span class="o">|</span>
<span class="o">|</span>  <span class="mi">3</span> <span class="o">|</span>    <span class="mi">2</span> <span class="o">|</span>    <span class="mi">200</span> <span class="o">|</span> <span class="err">一部</span>       <span class="o">|</span>
<span class="o">|</span>  <span class="mi">4</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>    <span class="mi">100</span> <span class="o">|</span> <span class="err">一部</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+------+--------+------------+</span>
</code></pre></div></div>

<p>可以发现dense_rank()对结果集进行了排序处理，并输出了根据目标字段排序的记录的排名序号，那么再回头看上面的SQL就非常好理解了，我们需要找到排名第二的记录，通过where限定，即可达到预期结果。</p>

<p>再回到上上个问题，如果我们希望查找每个部门中，薪水第二高的记录，怎么做？</p>

<p>聪明的你肯定想到，对部门字段进行group by，再找到第二高的记录，幸运的是，dense_rank()提供了根据字段进行分组的功能，就是<code class="language-plaintext highlighter-rouge">PARTITION BY</code>参数，那么来看一下SQL该怎么写：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">department</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">salary</span> <span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span> 
        <span class="n">salary</span><span class="p">,</span>
        <span class="n">department</span><span class="p">,</span>
        <span class="n">DENSE_RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">department</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">salary</span> <span class="k">DESC</span><span class="p">)</span> <span class="k">as</span> <span class="n">rn</span>
    <span class="k">FROM</span> <span class="n">Employee</span>
<span class="p">)</span> <span class="n">t</span> 
<span class="k">WHERE</span> <span class="n">rn</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="dense_rankrow_number-和-rank对比">DENSE_RANK()、ROW_NUMBER() 和 RANK()对比</h1>

<p>最后，我们来看一下MySQL中关于处理排名相关的几个函数，DENSE_RANK、ROW_NUMBER 和 RANK 是 SQL 中三种不同的窗口排名函数，它们的主要区别在于处理相同值（并列）的方式：</p>

<ol>
  <li>ROW_NUMBER()
    <ul>
      <li>为每一行分配唯一的序号，从 1 开始递增</li>
      <li>对于相同的值，按照它们在结果集中出现的顺序分配不同的序号</li>
      <li>结果总是连续的数字，不会出现间隔</li>
    </ul>
  </li>
  <li>RANK()
    <ul>
      <li>为每一行分配排名，从 1 开始</li>
      <li>对于相同的值，分配相同的排名</li>
      <li>排名可能会有间隔，因为相同值后的下一个排名会跳过已用的编号</li>
      <li>例如：1, 2, 2, 4, 5…（注意跳过了 3）</li>
    </ul>
  </li>
  <li>DENSE_RANK()
    <ul>
      <li>为每一行分配”密集排名”，从 1 开始</li>
      <li>对于相同的值，分配相同的排名</li>
      <li>排名始终是连续的，不会有间隔</li>
      <li>例如：1, 2, 2, 3, 4…（无跳过）</li>
    </ul>
  </li>
</ol>

<h1 id="结语">结语</h1>

<p>本篇，我们简单的探讨了SQL问题中非常经典的TOP N查找问题，学习了关于该种问题的几种解法，希望对你有所帮助。</p>]]></content><author><name>GitHub User</name></author><category term="MySQL" /><category term="MySQL" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Redis分布式锁实现指北</title><link href="http://localhost:4000/redis/2025/01/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97.html" rel="alternate" type="text/html" title="Redis分布式锁实现指北" /><published>2025-01-23T00:00:00+08:00</published><updated>2025-01-23T00:00:00+08:00</updated><id>http://localhost:4000/redis/2025/01/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97</id><content type="html" xml:base="http://localhost:4000/redis/2025/01/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97.html"><![CDATA[<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/Redis%20Lock.jpeg?raw=true" alt="banner" /></p>

<h2 id="背景">背景</h2>

<p>分布式锁在业务场景中的应用十分广泛，当你的服务部署在分布式的多节点集群中，在执行某一个方法时，需要控制并发的情况，保证同一时间只有一个请求可以执行，你一定需要分布式锁来实现。</p>

<p>最常见的分布式锁，一般就是Redis和ZK（亦或者MySQL的for update也可以充当），当然也有很多其他的实现，本篇的主角，就是Redis，我们来逐步使用实现一个简单易用的Redis分布式锁。</p>

<h2 id="redislock">RedisLock</h2>

<p>首先，我们先来回忆一下Java的Lock是怎么玩的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="c1">// do something...</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>很简单，很优雅，那么我们就仿照Java的API来实现我们的Redis Lock。</p>

<p>最直观的实现方式，就是使用Redis String的setnx方法，如果key存在就放弃，如果key不存在就set一个值，并指定过期时间，释放锁时，就把key删除，非常easy。</p>

<p>Version1：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisLockUtil</span> <span class="o">{</span>
  	<span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">JedisClient</span> <span class="n">jedisClient</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">lock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="s">".lock"</span><span class="o">;</span>
        <span class="no">UUID</span> <span class="n">uuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">uuid</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="s">"nx"</span><span class="o">,</span> <span class="s">"px"</span><span class="o">,</span> <span class="n">lockTimeout</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"OK"</span><span class="o">,</span> <span class="n">res</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">unlock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="s">".lock"</span><span class="o">;</span>
        <span class="nc">Long</span> <span class="n">res</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">del</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>  
</code></pre></div></div>

<p>Version1的实现非常简单，也可以满足基本的需求，但是有一个问题，任何线程，只要知道lockkey的名称，都可以调用unlock方法，这显然不是我们所希望的，所以我们在此基础上，进行一点优化，只有加锁的人，才可以释放锁，因此，我们需要保存一些额外的信息。</p>

<p>Version2:</p>

<p>我们新建一个Bean，存储RedisLock的相关信息，改造后我们的实现如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisLock</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="no">UUID</span> <span class="n">uuid</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">startLockTimeMillis</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">getLockTimeMillis</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">RedisLock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="no">UUID</span> <span class="n">uuid</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">startLockTimeMillis</span><span class="o">,</span> <span class="kt">long</span> <span class="n">getLockTimeMillis</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">uuid</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lockTimeout</span> <span class="o">=</span> <span class="n">lockTimeout</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">startLockTimeMillis</span> <span class="o">=</span> <span class="n">startLockTimeMillis</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">getLockTimeMillis</span> <span class="o">=</span> <span class="n">getLockTimeMillis</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="no">UUID</span> <span class="nf">getUuid</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">uuid</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getLockTimeout</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">lockTimeout</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLockTimeout</span><span class="o">(</span><span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lockTimeout</span> <span class="o">=</span> <span class="n">lockTimeout</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getGetLockTimeMillis</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">getLockTimeMillis</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setGetLockTimeMillis</span><span class="o">(</span><span class="kt">long</span> <span class="n">getLockTimeMillis</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">getLockTimeMillis</span> <span class="o">=</span> <span class="n">getLockTimeMillis</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getStartLockTimeMillis</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">startLockTimeMillis</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setStartLockTimeMillis</span><span class="o">(</span><span class="kt">long</span> <span class="n">startLockTimeMillis</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">startLockTimeMillis</span> <span class="o">=</span> <span class="n">startLockTimeMillis</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisLockUtil</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">JedisClient</span> <span class="n">jedisClient</span><span class="o">;</span>

    <span class="c1">// 释放锁的Lua脚本</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_UNLOCK</span> <span class="o">=</span>
            <span class="s">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> <span class="o">+</span>
                    <span class="s">"    redis.call('del', KEYS[1]); "</span> <span class="o">+</span>
                    <span class="s">"    return 'suc' "</span> <span class="o">+</span>
                    <span class="s">"else "</span> <span class="o">+</span>
                    <span class="s">"    return 'fail' "</span> <span class="o">+</span>
                    <span class="s">"end"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">RedisLock</span> <span class="nf">lock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="s">".lock"</span><span class="o">;</span>
        <span class="no">UUID</span> <span class="n">uuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">res</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">uuid</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="s">"nx"</span><span class="o">,</span> <span class="s">"px"</span><span class="o">,</span> <span class="n">lockTimeout</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"OK"</span><span class="o">,</span> <span class="n">res</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">RedisLock</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">uuid</span><span class="o">,</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">unlock</span><span class="o">(</span><span class="nc">RedisLock</span> <span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lock</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">getUuid</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
            <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
            <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_UNLOCK</span><span class="o">,</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">()),</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">)</span>
            <span class="o">);</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">response</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="s">"suc"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Well，改造后的方法，好像比Version1复杂了一些，别着急，其实并不复杂，为了保证原子性，删除lockkey部分我们采用了Lua脚本的方式实现，只有当lockkey的value校验一致时，才可以对key进行删除，这样就解决了Version1中出现的问题。</p>

<p>Version2基本可以运行的很好了，但是还有一个问题，我们知道Java的synchronized和ReentrantLock的实现，都是带有自旋抢锁功能的，当第一次没有获取到锁后，会尝试自旋等待，再次尝试抢锁，而我们的实现，好像并不具备这个功能，这怎么可以呢？那我们也要加入自旋。</p>

<p>Version3：</p>

<p>在RedisLock Bean中加入一些额外的信息：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisLock</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="no">UUID</span> <span class="n">uuid</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">startLockTimeMillis</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">getLockTimeMillis</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">tryCount</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">RedisLock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="no">UUID</span> <span class="n">uuid</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">startLockTimeMillis</span><span class="o">,</span> <span class="kt">long</span> <span class="n">getLockTimeMillis</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tryCount</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">uuid</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lockTimeout</span> <span class="o">=</span> <span class="n">lockTimeout</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">startLockTimeMillis</span> <span class="o">=</span> <span class="n">startLockTimeMillis</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">getLockTimeMillis</span> <span class="o">=</span> <span class="n">getLockTimeMillis</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tryCount</span> <span class="o">=</span> <span class="n">tryCount</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="no">UUID</span> <span class="nf">getUuid</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">uuid</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getLockTimeout</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">lockTimeout</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLockTimeout</span><span class="o">(</span><span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lockTimeout</span> <span class="o">=</span> <span class="n">lockTimeout</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getGetLockTimeMillis</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">getLockTimeMillis</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setGetLockTimeMillis</span><span class="o">(</span><span class="kt">long</span> <span class="n">getLockTimeMillis</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">getLockTimeMillis</span> <span class="o">=</span> <span class="n">getLockTimeMillis</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getStartLockTimeMillis</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">startLockTimeMillis</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setStartLockTimeMillis</span><span class="o">(</span><span class="kt">long</span> <span class="n">startLockTimeMillis</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">startLockTimeMillis</span> <span class="o">=</span> <span class="n">startLockTimeMillis</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getTryCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">tryCount</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTryCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">tryCount</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tryCount</span> <span class="o">=</span> <span class="n">tryCount</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>  
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisLockUtil</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">RedisDemo</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">JedisClient</span> <span class="n">jedisClient</span><span class="o">;</span>

    <span class="c1">//拿锁的EVAL函数</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_LOCK</span> <span class="o">=</span> <span class="s">"return redis.call('SET', KEYS[1], ARGV[1], 'NX', 'PX', ARGV[2]) "</span><span class="o">;</span>

    <span class="c1">// 释放锁的Lua脚本</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_UNLOCK</span> <span class="o">=</span>
            <span class="s">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> <span class="o">+</span>
                    <span class="s">"    redis.call('del', KEYS[1]); "</span> <span class="o">+</span>
                    <span class="s">"    return 'suc' "</span> <span class="o">+</span>
                    <span class="s">"else "</span> <span class="o">+</span>
                    <span class="s">"    return 'fail' "</span> <span class="o">+</span>
                    <span class="s">"end"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">RedisLock</span> <span class="nf">lock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tryLockTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="s">".lock"</span><span class="o">;</span>
            <span class="no">UUID</span> <span class="n">uuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">();</span>
            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">tryCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">tryLockTimeout</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">tryLockTimeout</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
                <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_LOCK</span><span class="o">,</span>
                        <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">key</span><span class="o">),</span>
                        <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">lockTimeout</span><span class="o">))</span>
                <span class="o">);</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
                <span class="n">tryCount</span><span class="o">++;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="s">"OK"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">()))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="nf">RedisLock</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">uuid</span><span class="o">,</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">(),</span> <span class="n">tryCount</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Fail to get lock key: {}"</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">unlock</span><span class="o">(</span><span class="nc">RedisLock</span> <span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lock</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">getUuid</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
            <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
            <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_UNLOCK</span><span class="o">,</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">()),</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">)</span>
            <span class="o">);</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">response</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="s">"suc"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          	<span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Fail to unlock key: {}"</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Well，Version3版本可以算是一个里程碑的版本，我们在获取锁的方法中，加入了自旋抢锁的功能，可以指定抢锁的超时时间，在此之前，当前线程会一直自旋尝试获取锁，在这个版本中，我们将加锁的方式，也换成了LUA脚本，由于老旧版本的Redis还不支持setnx指定过期时间，为了兼容性考虑，我们这里采用LUA的方式。</p>

<p>Version3已经是一个非常可用的版本了，但是如果我们有更高的要求，还是有一点问题的，就是线程安全问题，假如线程A获取锁成功，并拿到了RedisLock对象，而线程B拿着该对象，调用解锁的方法，是可以解锁成功的，虽然这是一种极端场景，但是也确实有可能发生，为了避免这个问题，我们需要考虑线程一致性的问题，即加锁和解锁的线程，必须是同一线程。</p>

<p>Version4：</p>

<p>在RedisLock Bean中加入一些额外的信息：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisLock</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="no">UUID</span> <span class="n">uuid</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">;</span>  <span class="c1">// 新增线程ID字段</span>
  	<span class="o">.....</span><span class="na">省略其他代码</span><span class="o">.....</span>
      
    
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisLockUtil</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">RedisDemo</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">JedisClient</span> <span class="n">jedisClient</span><span class="o">;</span>

    <span class="c1">//拿锁的EVAL函数</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_LOCK</span> <span class="o">=</span> <span class="s">"return redis.call('SET', KEYS[1], ARGV[1], 'NX', 'PX', ARGV[2]) "</span><span class="o">;</span>

    <span class="c1">// 释放锁的Lua脚本</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_UNLOCK</span> <span class="o">=</span>
            <span class="s">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> <span class="o">+</span>
                    <span class="s">"    redis.call('del', KEYS[1]); "</span> <span class="o">+</span>
                    <span class="s">"    return 'suc' "</span> <span class="o">+</span>
                    <span class="s">"else "</span> <span class="o">+</span>
                    <span class="s">"    return 'fail' "</span> <span class="o">+</span>
                    <span class="s">"end"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">RedisLock</span> <span class="nf">lock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tryLockTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="s">".lock"</span><span class="o">;</span>
            <span class="no">UUID</span> <span class="n">uuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">();</span>
            <span class="c1">// 获取当前线程ID</span>
            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">uuid</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">tryCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">tryLockTimeout</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">tryLockTimeout</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
                <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_LOCK</span><span class="o">,</span>
                        <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">key</span><span class="o">),</span>
                        <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">lockTimeout</span><span class="o">))</span>  <span class="c1">// 使用包含线程ID的lockValue</span>
                <span class="o">);</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
                <span class="n">tryCount</span><span class="o">++;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="s">"OK"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">()))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="nf">RedisLock</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">uuid</span><span class="o">,</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">(),</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">(),</span> <span class="n">tryCount</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Fail to get lock key: {}"</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">unlock</span><span class="o">(</span><span class="nc">RedisLock</span> <span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lock</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 验证当前线程是否为加锁线程</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">()</span> <span class="o">!=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"Current thread[{}] is not the lock owner[{}], will not unlock"</span><span class="o">,</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">(),</span> <span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">());</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">getUuid</span><span class="o">().</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">();</span>
            <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
            <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_UNLOCK</span><span class="o">,</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">()),</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">)</span>  <span class="c1">// 使用包含线程ID的lockValue</span>
            <span class="o">);</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">response</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="s">"suc"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Failed to release lock: {}"</span><span class="o">,</span> <span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在Version4版本中，我们中RedisLock中加入了ThreadId字段，表示当前获取锁的线程ID，在加锁和解锁时，分别加入当前线程的ID标识，保证解锁的线程必须和加锁的线程一致。</p>

<p>至此，我们基本上完成了Redis分布式锁的实现，最后的Version4已经是一个生产环境可用的版本，足以应对绝对大部分的业务场景使用。</p>

<h3 id="think-more">Think More</h3>

<p>But，我们是追求完美主义的程序员（Doge），Version4已经足够可用，但是再想想，可否继续优化呢？</p>

<p>设想一个场景，加入线程A获取到锁资源，将锁的过期时间设定为3秒，然后线程A就去执行业务逻辑代码了，但是业务代码中，存在一个调用外部API的方法，这个方法出了点意外，耗时超过了3秒，此时锁已经过期，但是业务逻辑并没有执行完毕，此时等待抢锁的线程B，正好就拿到了锁，执行相同的业务代码，这显然不是我们所期望的，那么该如何解决？</p>

<p>如果使用过Redisson的童鞋想必已经猜到了，我们需要一个锁（Lock）的看门狗（Watch Dog），来检查锁是否需要进行续期操作。</p>

<p>Version5：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisLockUtil</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">RedisLockUtil</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">JedisClient</span> <span class="n">jedisClient</span><span class="o">;</span>

    <span class="c1">// 锁的过期时间，单位毫秒</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">DEFAULT_LOCK_TIMEOUT</span> <span class="o">=</span> <span class="mi">3000</span><span class="o">;</span>

    <span class="c1">// 争抢锁的超时时间，单位毫秒，0代表永不超时（一直抢到锁为止）</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">DEFAULT_TRY_LOCK_TIMEOUT</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="c1">//拿锁的EVAL函数</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_LOCK</span> <span class="o">=</span> <span class="s">"return redis.call('SET', KEYS[1], ARGV[1], 'NX', 'PX', ARGV[2]) "</span><span class="o">;</span>

    <span class="c1">// 释放锁的Lua脚本</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_UNLOCK</span> <span class="o">=</span>
            <span class="s">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> <span class="o">+</span>
                    <span class="s">"    redis.call('del', KEYS[1]); "</span> <span class="o">+</span>
                    <span class="s">"    return 'suc' "</span> <span class="o">+</span>
                    <span class="s">"else "</span> <span class="o">+</span>
                    <span class="s">"    return 'fail' "</span> <span class="o">+</span>
                    <span class="s">"end"</span><span class="o">;</span>

    <span class="c1">// 添加续期相关的常量</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_RENEW</span> <span class="o">=</span>
            <span class="s">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> <span class="o">+</span>
                    <span class="s">"    redis.call('pexpire', KEYS[1], ARGV[2]); "</span> <span class="o">+</span>
                    <span class="s">"    return 'suc' "</span> <span class="o">+</span>
                    <span class="s">"else "</span> <span class="o">+</span>
                    <span class="s">"    return 'fail' "</span> <span class="o">+</span>
                    <span class="s">"end"</span><span class="o">;</span>

    <span class="c1">// 续期时间点（锁过期时间的2/3处开始续期）</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="no">RENEW_FACTOR</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">RedisLock</span> <span class="nf">lock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">lock</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="no">DEFAULT_LOCK_TIMEOUT</span><span class="o">,</span> <span class="no">DEFAULT_TRY_LOCK_TIMEOUT</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">lockAndExecute</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">lockAndExecute</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="no">DEFAULT_LOCK_TIMEOUT</span><span class="o">,</span> <span class="no">DEFAULT_TRY_LOCK_TIMEOUT</span><span class="o">,</span> <span class="n">supplier</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockAndExecute</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Runnable</span> <span class="n">runnable</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lockAndExecute</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="no">DEFAULT_LOCK_TIMEOUT</span><span class="o">,</span> <span class="no">DEFAULT_TRY_LOCK_TIMEOUT</span><span class="o">,</span> <span class="n">runnable</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 获取分布式锁
     *
     * @param key   redis key名称
     * @param lockTimeout   锁时长
     * @param tryLockTimeout   尝试获取锁等待时间
     * @return
     */</span>
    <span class="kd">public</span> <span class="nc">RedisLock</span> <span class="nf">lock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tryLockTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="s">".lock"</span><span class="o">;</span>
            <span class="no">UUID</span> <span class="n">uuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">();</span>
            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">uuid</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">tryCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">tryLockTimeout</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">tryLockTimeout</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
                <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_LOCK</span><span class="o">,</span>
                        <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">key</span><span class="o">),</span>
                        <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">lockTimeout</span><span class="o">))</span>
                <span class="o">);</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
                <span class="n">tryCount</span><span class="o">++;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="s">"OK"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">()))</span> <span class="o">{</span>
                    <span class="nc">RedisLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisLock</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">uuid</span><span class="o">,</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">(),</span> 
                            <span class="n">lockTimeout</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">(),</span> <span class="n">tryCount</span><span class="o">);</span>
                    <span class="c1">// 启动续期守护线程</span>
                    <span class="n">startRenewThread</span><span class="o">(</span><span class="n">lock</span><span class="o">);</span>
                    <span class="k">return</span> <span class="n">lock</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Fail to get lock key: {}"</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 启动续期守护线程
     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">startRenewThread</span><span class="o">(</span><span class="nc">RedisLock</span> <span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">renewThread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">renewInterval</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getLockTimeout</span><span class="o">()</span> <span class="o">*</span> <span class="no">RENEW_FACTOR</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(!</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">renewInterval</span><span class="o">);</span>
                    <span class="kt">boolean</span> <span class="n">renewed</span> <span class="o">=</span> <span class="n">renewLock</span><span class="o">(</span><span class="n">lock</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">renewed</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">renewThread</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">renewThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">setRenewThread</span><span class="o">(</span><span class="n">renewThread</span><span class="o">);</span>  <span class="c1">// 需要在RedisLock类中添加renewThread字段</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 续期锁
     */</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">renewLock</span><span class="o">(</span><span class="nc">RedisLock</span> <span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">getUuid</span><span class="o">().</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">();</span>
            <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
            <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_RENEW</span><span class="o">,</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">()),</span>
                    <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getLockTimeout</span><span class="o">()))</span>
            <span class="o">);</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
            <span class="kt">boolean</span> <span class="n">success</span> <span class="o">=</span> <span class="n">response</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="s">"suc"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">success</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Successfully renewed lock: {}"</span><span class="o">,</span> <span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"Failed to renew lock: {}"</span><span class="o">,</span> <span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">success</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Error while renewing lock: {}"</span><span class="o">,</span> <span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 加锁执行业务逻辑，执行完成后自动释放锁
     *
     * @param key      锁的key
     * @param supplier 需要执行的业务逻辑
     * @param &lt;T&gt;      返回值类型
     * @return 业务逻辑的执行结果
     */</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">lockAndExecute</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tryLockTimeout</span><span class="o">,</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">RedisLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span> <span class="o">=</span> <span class="n">lock</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="n">tryLockTimeout</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">nonNull</span><span class="o">(</span><span class="n">lock</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"获取锁失败: "</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">nonNull</span><span class="o">(</span><span class="n">lock</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">unlock</span><span class="o">(</span><span class="n">lock</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 加锁执行无返回值的业务逻辑，执行完成后自动释放锁
     *
     * @param key      锁的key
     * @param runnable 需要执行的业务逻辑
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockAndExecute</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tryLockTimeout</span><span class="o">,</span> <span class="nc">Runnable</span> <span class="n">runnable</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">RedisLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span> <span class="o">=</span> <span class="n">lock</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="n">tryLockTimeout</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">nonNull</span><span class="o">(</span><span class="n">lock</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">runnable</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"获取锁失败: "</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">nonNull</span><span class="o">(</span><span class="n">lock</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">unlock</span><span class="o">(</span><span class="n">lock</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">unlock</span><span class="o">(</span><span class="nc">RedisLock</span> <span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lock</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 验证当前线程是否为加锁线程</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">()</span> <span class="o">!=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"Current thread[{}] is not the lock owner[{}], will not unlock"</span><span class="o">,</span> 
                <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">(),</span> <span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">());</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 停止续期线程</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getRenewThread</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">getRenewThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">getUuid</span><span class="o">().</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">();</span>
            <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
            <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_UNLOCK</span><span class="o">,</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">()),</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">)</span>  <span class="c1">// 使用包含线程ID的lockValue</span>
            <span class="o">);</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">response</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="s">"suc"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Failed to release lock: {}"</span><span class="o">,</span> <span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在这个版本中，我们加入了看门狗的锁续期逻辑，在锁的过期时间达到我们指定的阈值时，会触发锁续期的线程，执行锁续期逻辑，同时我们还加入了一些门面方法，将RedisLockUtil更加易用，就此，我们基本完成了一个非常优秀的分布式锁实现。</p>

<h3 id="something-else">Something Else…</h3>

<p>关于RedisLock的完整实现基本完成，如果了解过Java的ReentrantLock的同学应该知道，concurrent package中的锁的实现，基本都是基于AQS队列实现的，如果您对AQS不太了解，可以点击这里：</p>

<p><a href="https://blog.csdn.net/wtopps/article/details/82054186">聊聊并发：（七）concurrent包之AbstractQueuedSynchronizer分析 </a></p>

<p>那么我们的RedisLock是否也可以与AQS结合呢？这是个有意思的问题，我们来一起尝试一下：</p>

<p>Version6：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisLock</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="no">UUID</span> <span class="n">uuid</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">startLockTimeMillis</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">getLockTimeMillis</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">tryCount</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Thread</span> <span class="n">renewThread</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RedisLockUtil</span><span class="o">.</span><span class="na">Sync</span> <span class="n">sync</span><span class="o">;</span>  <span class="c1">// 添加sync字段</span>

    <span class="kd">public</span> <span class="nf">RedisLock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="no">UUID</span> <span class="n">uuid</span><span class="o">,</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">startLockTimeMillis</span><span class="o">,</span> <span class="kt">long</span> <span class="n">getLockTimeMillis</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tryCount</span><span class="o">,</span> <span class="nc">RedisLockUtil</span><span class="o">.</span><span class="na">Sync</span> <span class="n">sync</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">uuid</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">threadId</span> <span class="o">=</span> <span class="n">threadId</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lockTimeout</span> <span class="o">=</span> <span class="n">lockTimeout</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">startLockTimeMillis</span> <span class="o">=</span> <span class="n">startLockTimeMillis</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">getLockTimeMillis</span> <span class="o">=</span> <span class="n">getLockTimeMillis</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tryCount</span> <span class="o">=</span> <span class="n">tryCount</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sync</span> <span class="o">=</span> <span class="n">sync</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">.....</span><span class="na">省略部分代码</span><span class="o">.....</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisLockUtil</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">RedisLockUtil</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">JedisClient</span> <span class="n">jedisClient</span><span class="o">;</span>

    <span class="c1">//拿锁的EVAL函数</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_LOCK</span> <span class="o">=</span> <span class="s">"return redis.call('SET', KEYS[1], ARGV[1], 'NX', 'PX', ARGV[2]) "</span><span class="o">;</span>

    <span class="c1">// 释放锁的Lua脚本</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_UNLOCK</span> <span class="o">=</span>
            <span class="s">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> <span class="o">+</span>
                    <span class="s">"    redis.call('del', KEYS[1]); "</span> <span class="o">+</span>
                    <span class="s">"    return 'suc' "</span> <span class="o">+</span>
                    <span class="s">"else "</span> <span class="o">+</span>
                    <span class="s">"    return 'fail' "</span> <span class="o">+</span>
                    <span class="s">"end"</span><span class="o">;</span>

    <span class="c1">// 添加续期相关的常量</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">LUA_SCRIPT_RENEW</span> <span class="o">=</span>
            <span class="s">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> <span class="o">+</span>
                    <span class="s">"    redis.call('pexpire', KEYS[1], ARGV[2]); "</span> <span class="o">+</span>
                    <span class="s">"    return 'suc' "</span> <span class="o">+</span>
                    <span class="s">"else "</span> <span class="o">+</span>
                    <span class="s">"    return 'fail' "</span> <span class="o">+</span>
                    <span class="s">"end"</span><span class="o">;</span>

    <span class="c1">// 续期时间点（锁过期时间的2/3处开始续期）</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="no">RENEW_FACTOR</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span>


    <span class="cm">/**
     * 基于AQS的同步器实现
     */</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="nc">AbstractQueuedSynchronizer</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Redis1</span> <span class="n">lockUtil</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">key</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">RedisLock</span> <span class="n">redisLock</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Sync</span><span class="o">(</span><span class="nc">Redis1</span> <span class="n">lockUtil</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">lockUtil</span> <span class="o">=</span> <span class="n">lockUtil</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">lockTimeout</span> <span class="o">=</span> <span class="n">lockTimeout</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 尝试获取Redis锁</span>
            <span class="n">redisLock</span> <span class="o">=</span> <span class="n">lockUtil</span><span class="o">.</span><span class="na">tryLock</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">redisLock</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">redisLock</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">lockUtil</span><span class="o">.</span><span class="na">unlock</span><span class="o">(</span><span class="n">redisLock</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">RedisLock</span> <span class="nf">getRedisLock</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">redisLock</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 尝试获取锁的内部方法，不包含AQS逻辑
     */</span>
    <span class="kd">private</span> <span class="nc">RedisLock</span> <span class="nf">tryLock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="nc">Sync</span> <span class="n">sync</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 将原来lock方法的实现移到这里</span>
        <span class="kt">long</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="s">".lock"</span><span class="o">;</span>
            <span class="no">UUID</span> <span class="n">uuid</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">();</span>
            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">uuid</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>

            <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
            <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_LOCK</span><span class="o">,</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">key</span><span class="o">),</span>
                    <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">lockTimeout</span><span class="o">))</span>
            <span class="o">);</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="s">"OK"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">()))</span> <span class="o">{</span>
                <span class="nc">RedisLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisLock</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">uuid</span><span class="o">,</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">(),</span>
                        <span class="n">lockTimeout</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">(),</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sync</span><span class="o">);</span>
                <span class="n">startRenewThread</span><span class="o">(</span><span class="n">lock</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">lock</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Fail to get lock key: {}"</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 获取分布式锁（使用AQS实现线程排队）
     */</span>
    <span class="kd">public</span> <span class="nc">RedisLock</span> <span class="nf">lock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Sync</span> <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Sync</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">lockTimeout</span><span class="o">);</span>
        <span class="n">sync</span><span class="o">.</span><span class="na">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 阻塞直到获取到锁</span>
        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getRedisLock</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 尝试获取分布式锁（非阻塞）
     */</span>
    <span class="kd">public</span> <span class="nc">RedisLock</span> <span class="nf">tryLock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Sync</span> <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Sync</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">lockTimeout</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquire</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">?</span> <span class="n">sync</span><span class="o">.</span><span class="na">getRedisLock</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 带超时的尝试获取分布式锁
     */</span>
    <span class="kd">public</span> <span class="nc">RedisLock</span> <span class="nf">tryLock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">lockTimeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">tryLockTimeout</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Sync</span> <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Sync</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">lockTimeout</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquireNanos</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">tryLockTimeout</span><span class="o">))</span> <span class="o">?</span> <span class="n">sync</span><span class="o">.</span><span class="na">getRedisLock</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="cm">/**
     * 启动续期守护线程
     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">startRenewThread</span><span class="o">(</span><span class="nc">RedisLock</span> <span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">renewThread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">renewInterval</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getLockTimeout</span><span class="o">()</span> <span class="o">*</span> <span class="no">RENEW_FACTOR</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(!</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">renewInterval</span><span class="o">);</span>
                    <span class="kt">boolean</span> <span class="n">renewed</span> <span class="o">=</span> <span class="n">renewLock</span><span class="o">(</span><span class="n">lock</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">renewed</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">renewThread</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">renewThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">setRenewThread</span><span class="o">(</span><span class="n">renewThread</span><span class="o">);</span>  <span class="c1">// 需要在RedisLock类中添加renewThread字段</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 续期锁
     */</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">renewLock</span><span class="o">(</span><span class="nc">RedisLock</span> <span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">getUuid</span><span class="o">().</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">();</span>
            <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
            <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_RENEW</span><span class="o">,</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">()),</span>
                    <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getLockTimeout</span><span class="o">()))</span>
            <span class="o">);</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
            <span class="kt">boolean</span> <span class="n">success</span> <span class="o">=</span> <span class="n">response</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="s">"suc"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">success</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"Successfully renewed lock: {}"</span><span class="o">,</span> <span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"Failed to renew lock: {}"</span><span class="o">,</span> <span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">success</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Error while renewing lock: {}"</span><span class="o">,</span> <span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">unlock</span><span class="o">(</span><span class="nc">RedisLock</span> <span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lock</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 验证当前线程是否为加锁线程</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">()</span> <span class="o">!=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"Current thread[{}] is not the lock owner[{}], will not unlock"</span><span class="o">,</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">(),</span> <span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">());</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 停止续期线程</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getRenewThread</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">getRenewThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="nc">String</span> <span class="n">lockValue</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">getUuid</span><span class="o">().</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">lock</span><span class="o">.</span><span class="na">getThreadId</span><span class="o">();</span>
            <span class="nc">JedisClusterPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">jedisClient</span><span class="o">.</span><span class="na">getPipelined</span><span class="o">();</span>
            <span class="nc">Response</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="no">LUA_SCRIPT_UNLOCK</span><span class="o">,</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">()),</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">lockValue</span><span class="o">)</span>  <span class="c1">// 使用包含线程ID的lockValue</span>
            <span class="o">);</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">response</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="s">"suc"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Failed to release lock: {}"</span><span class="o">,</span> <span class="n">lock</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="结语">结语</h2>

<p>本篇，我们从0-1，从简单到复杂完整了实现了一个Redis分布式锁，实现的细节难免粗糙，如果有问题请您指出，希望本篇可以给您提供一个思路，谢谢。</p>]]></content><author><name>GitHub User</name></author><category term="Redis" /><category term="Redis" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">记一次业务MySQL死锁</title><link href="http://localhost:4000/mysql/2024/12/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%9A%E5%8A%A1MySQL%E6%AD%BB%E9%94%81case.html" rel="alternate" type="text/html" title="记一次业务MySQL死锁" /><published>2024-12-12T00:00:00+08:00</published><updated>2024-12-12T00:00:00+08:00</updated><id>http://localhost:4000/mysql/2024/12/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%9A%E5%8A%A1MySQL%E6%AD%BB%E9%94%81case</id><content type="html" xml:base="http://localhost:4000/mysql/2024/12/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%9A%E5%8A%A1MySQL%E6%AD%BB%E9%94%81case.html"><![CDATA[<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/Problem%20Investigation.jpeg?raw=true" alt="banner" /></p>

<h2 id="问题">问题</h2>

<p>线上服务出现服务告警，查询日志现场，错误信息如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Caused by: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Deadlock found when trying to get lock<span class="p">;</span> try restarting transaction
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException<span class="o">(</span>SQLError.java:124<span class="o">)</span>
	at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException<span class="o">(</span>SQLExceptionsMapping.java:122<span class="o">)</span>
	at com.mysql.cj.jdbc.ClientPreparedStatement.executeInternal<span class="o">(</span>ClientPreparedStatement.java:916<span class="o">)</span>
	at com.mysql.cj.jdbc.ClientPreparedStatement.executeQuery<span class="o">(</span>ClientPreparedStatement.java:972<span class="o">)</span>
	at com.alibaba.druid.pool.DruidPooledPreparedStatement.executeQuery<span class="o">(</span>DruidPooledPreparedStatement.java:213<span class="o">)</span>
	at org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract<span class="o">(</span>ResultSetReturnImpl.java:57<span class="o">)</span>
	... 113 common frames omitted
	
....

Deadlock found when trying to get lock<span class="p">;</span> try restarting transaction
</code></pre></div></div>

<p>根据日志信息，很显然是一个MySQL死锁的case。</p>

<h2 id="问题分析">问题分析</h2>

<p>根据报错信息，定位到报错的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="nc">AuditProcessRecord</span> <span class="n">auditProcessRecord</span> <span class="o">:</span> <span class="n">auditProcessRecords</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">auditProcessRecord</span><span class="o">.</span><span class="na">getId</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">auditProcessRecordId</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">auditProcessRecord</span><span class="o">.</span><span class="na">setAuditStatus</span><span class="o">(</span><span class="nc">AuditProcessStatus</span><span class="o">.</span><span class="na">AUDIT_PASS</span><span class="o">.</span><span class="na">getStatus</span><span class="o">());</span>
        <span class="n">auditProcessRecordRepo</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">auditProcessRecord</span><span class="o">);</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 检查是否存在审核中的流程，如果存在，继续等待剩余流程结束</span>
<span class="c1">// 事务中，加读锁，当前读</span>
<span class="c1">// 不加锁，快照读</span>
<span class="kt">int</span> <span class="n">auditingRecordCount</span> <span class="o">=</span> <span class="n">auditProcessRecordRepo</span><span class="o">.</span><span class="na">existsAuditingRecordInLock</span><span class="o">(</span><span class="n">auditId</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">auditingRecordCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"LotteryAudit process is pending auditItem, waiting. lotteryId={}, auditId={}"</span><span class="o">,</span>
            <span class="n">lotteryAuditRecord</span><span class="o">.</span><span class="na">getLotteryId</span><span class="o">(),</span> <span class="n">auditId</span><span class="o">);</span>
    <span class="k">return</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>报错的方法是existsAuditingRecordInLock，看一下实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Query</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"select count(*) from audit_process_record where audit_id = ?1 and audit_status = 0 LOCK IN SHARE MODE"</span><span class="o">,</span><span class="n">nativeQuery</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="nc">Integer</span> <span class="nf">existsAuditingRecordInLock</span><span class="o">(</span><span class="nc">String</span> <span class="n">auditId</span><span class="o">);</span>
</code></pre></div></div>

<p>existsAuditingRecordInLock的实现可以看到，使用了共享锁查询audit_process_record的行数，线上MySQL的事务级别使用RR，使用共享锁的目的，应该是希望避免快照读，而是使用当前读，并发场景下，可以查询到其他线程的最新数据，但问题也恰恰出在这里。</p>

<h4 id="执行过程分析">执行过程分析</h4>

<p>假定有两个线程，同时执行上面的代码，两个线程同时处理不同的 auditProcessRecordId，但是相同的 auditId：</p>

<p>线程A：</p>

<ol>
  <li>BEGIN;</li>
  <li>更新记录1：
UPDATE audit_process_record SET audit_status = 1 WHERE id = 1  // 获得id=1记录的排他锁</li>
  <li>SELECT COUNT(*) … LOCK IN SHARE MODE   // 尝试获取audit_id=1的所有记录的共享锁
需要获取id=2记录的共享锁，但被线程B的排他锁阻塞</li>
</ol>

<p>线程B：</p>
<ol>
  <li>BEGIN;</li>
  <li>更新记录2：
UPDATE audit_process_record SET audit_status = 1 WHERE id = 2  // 获得id=2记录的排他锁</li>
  <li>SELECT COUNT(*) … LOCK IN SHARE MODE   // 尝试获取audit_id=1的所有记录的共享锁
需要获取id=1记录的共享锁，但被线程A的排他锁阻塞</li>
</ol>

<p>死锁原因：</p>

<p>线程A先获得记录1的排他锁，然后要获取所有记录（包括记录2）的共享锁</p>

<p>线程B先获得记录2的排他锁，然后要获取所有记录（包括记录1）的共享锁</p>

<p>形成循环等待：</p>

<p>​	A持有记录1排他锁，等待记录2的共享锁</p>

<p>​	B持有记录2排他锁，等待记录1的共享锁</p>

<h2 id="问题解决">问题解决</h2>

<p>方法一：</p>

<p>使用FOR UPDATE替代LOCK IN SHARE MODE</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="nf">COUNT</span><span class="o">(*)</span> <span class="no">FROM</span> <span class="n">audit_process_record</span> <span class="no">WHERE</span> <span class="n">audit_id</span> <span class="o">=</span> <span class="o">?</span><span class="mi">1</span> <span class="no">AND</span> <span class="n">audit_status</span> <span class="o">=</span> <span class="mi">0</span> 
<span class="no">FOR</span> <span class="no">UPDATE</span>
</code></pre></div></div>

<p>FOR UPDATE是独占锁（排他锁），它在读取数据时会锁定记录，并且同时防止其他事务读取或修改这些记录。在事务中使用 FOR UPDATE 时，其他事务将无法对加锁的记录执行 SELECT 或任何修改操作，直到当前事务提交或回滚。</p>

<p>方法二：</p>

<p>调整事物隔离级别，RR变为RC</p>

<p>方法三：</p>

<p>使用其他的分布式锁，例如Redis或者ZK，代替MySQL的锁操作。</p>]]></content><author><name>GitHub User</name></author><category term="MySQL" /><category term="MySQL" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Protobuf Varint序列化原理</title><link href="http://localhost:4000/others/2024/11/11/Protobuf-Varint%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86.html" rel="alternate" type="text/html" title="Protobuf Varint序列化原理" /><published>2024-11-11T00:00:00+08:00</published><updated>2024-11-11T00:00:00+08:00</updated><id>http://localhost:4000/others/2024/11/11/Protobuf%20Varint%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86</id><content type="html" xml:base="http://localhost:4000/others/2024/11/11/Protobuf-Varint%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86.html"><![CDATA[<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/Protobuf.jpeg?raw=true" alt="banner" /></p>

<h2 id="前言">前言</h2>

<p>Protocol Buffers（简称 protobuf）使用 varint（可变长整数）格式来序列化一些整数类型（如 int32, int64, uint32, uint64 等）。varint 的基本原理是将整数按照字节进行分段编码，以尽可能节省存储空间。这种编码方式使得对于较小的整数值，占用的字节数非常少，而对于较大的整数，则会根据需要动态增加字节。</p>

<h2 id="varint-序列化的工作原理">Varint 序列化的工作原理</h2>

<p><strong>字节按位拆分</strong>：Protobuf 将整数值分解为一组 7 位的块（字节），每个字节保存一个 7 位的数据</p>

<p><strong>高位标记</strong>：每个字节的最高位（第 8 位）是一个标志位，用于指示该字节是否是最后一个字节。具体地：</p>

<ul>
  <li>如果字节的最高位为 1，表示该字节之后还有更多字节（即这个字节不是最后一个字节）</li>
  <li>如果字节的最高位为 0，表示这是该整数的最后一个字节</li>
</ul>

<p><strong>分块与压缩：</strong>通过将整数分成多个 7 位的块，Protobuf 能够将小整数用一个字节表示，而对较大的整数则按需增加字节数</p>

<h2 id="why-varint">Why Varint？</h2>

<p>当我们日常处理的数字大多数都是比较小的数值时，比如1、2、3这样的整数，使用标准的32位二进制格式来存储这些值实际上是非常浪费资源的做法。</p>

<p>这是因为每个这样的小数都会占用整整32位的空间，而其中大部分位都被设置为了0，这导致了存储空间上的极大浪费。为了解决这个问题，人们提出了变长整数（varint）编码方案。</p>

<p>Varint是一种能够根据实际需要动态调整所占位数的数据表示方法。对于较小的整数来说，它可以在保证信息完整性的前提下大大减少所需的空间。具体而言，当一个整数足够小时，它可以被编码成较少的字节；随着数值增大，才逐渐增加额外的字节数以容纳更大的数值范围。这样做的好处是显著提高了小数值情况下的存储效率。</p>

<p>然而，虽然varint在处理小数字方面表现优异，但如果应用场景中频繁出现非常大的整数，则采用这种编码方式反而可能会消耗比固定长度编码更多的空间。这是因为在varint编码机制下，较大的数值需要通过多个字节来表达，并且每个字节还必须包含一些额外的信息（如标志位），用来指示当前字节是否属于该数值的一部分以及是否还有后续字节。因此，在某些特定条件下，与直接使用固定的32位或64位表示法相比，varint可能不是最优的选择。</p>

<h2 id="具体编码流程">具体编码流程</h2>

<ol>
  <li>
    <p>假设要编码一个 32 位的整数 ( n )，下面是具体的编码步骤：</p>
  </li>
  <li>
    <p>将整数 ( n ) 拆分为多个 7 位块，按顺序存储在字节流中。</p>

    <p>对于每个字节：</p>

    <ul>
      <li>
        <p>取整数的低 7 位（n &amp; 0x7F），这部分将存储在字节的低 7 位中。</p>
      </li>
      <li>
        <p>如果整数还剩余部分，右移 7 位（n »= 7），然后继续编码下一字节。</p>
      </li>
      <li>
        <p>每个字节的高位（第 8 位）标记是否是最后一个字节。如果是最后一个字节，设置高位为 0，否则设置高位为 1。</p>
      </li>
    </ul>
  </li>
</ol>

<h3 id="举个例子">举个例子</h3>
<p>假设我们要编码整数 300：</p>

<ol>
  <li>
    <p><strong>300 转换为二进制：</strong></p>

    <p>300 的二进制表示是 100101100（9 位二进制）。</p>
  </li>
  <li>
    <p><strong>将整数分解成 7 位块：</strong></p>

    <p>第一个 7 位块是 1001011（即 75，也就是 300 除以 128 的商，右移 7 位）。</p>

    <p>第二个 7 位块是 00（即 44，剩下的 44 位）。</p>
  </li>
  <li>
    <p><strong>每个字节的高位：</strong></p>

    <p>对于第一个字节，1001011 后面还有字节，因此最高位是 1。</p>

    <p>对于第二个字节，00 是最后一个字节，最高位是 0。</p>
  </li>
  <li>
    <p><strong>最终编码：</strong></p>

    <p>第一个字节（75）编码为 0x4B，高位为 1。</p>

    <p>第二个字节（44）编码为 0x2C，高位为 0。</p>

    <p>因此，300 被编码为两个字节：0x4B 0x2C。</p>
  </li>
</ol>

<h2 id="解码过程">解码过程</h2>

<p>解码时，Protobuf 会根据高位标记是否为 1 来判断是否继续读取下一个字节。直到遇到高位为 0 的字节，表示所有数据已经读取完毕。</p>

<ol>
  <li>从字节流中读取，每次读取一个字节。</li>
  <li>去掉高位，将每个字节的低 7 位合并到结果中。</li>
  <li>根据高位判断是否继续读取，如果高位是 1，则继续读取下一个字节；如果高位是 0，表示所有字节都已经读取完毕。</li>
</ol>

<p><img src="https://github.com/wtopps/wtopps.github.io/blob/master/images/protobuf%20varint%20process.png?raw=true" alt="serialize demo" /></p>

<p>再看一个Google官方文档给出的示例：</p>

<blockquote>
  <p>And here is 150, encoded as <code class="language-plaintext highlighter-rouge">9601</code> – this is a bit more complicated:</p>
</blockquote>

<div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">10010110</span> <span class="mo">00000001</span>
<span class="err">^</span> <span class="n">msb</span>    <span class="err">^</span> <span class="n">msb</span>
</code></pre></div></div>

<blockquote>
  <p>How do you figure out that this is 150? First you drop the MSB from each byte, as this is just there to tell us whether we’ve reached the end of the number (as you can see, it’s set in the first byte as there is more than one byte in the varint). These 7-bit payloads are in little-endian order. Convert to big-endian order, concatenate, and interpret as an unsigned 64-bit integer:</p>
</blockquote>

<div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">10010110</span> <span class="mo">00000001</span>        <span class="c1">// Original inputs.</span>
 <span class="mo">0010110</span>  <span class="mo">0000001</span>        <span class="c1">// Drop continuation bits.</span>
 <span class="mo">0000001</span>  <span class="mo">0010110</span>        <span class="c1">// Convert to big-endian.</span>
   <span class="mo">00000010010110</span>        <span class="c1">// Concatenate.</span>
 <span class="mi">128</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">150</span>  <span class="c1">// Interpret as an unsigned 64-bit integer.</span>
</code></pre></div></div>

<h2 id="优势">优势</h2>

<p>节省空间：由于小数字只需要一个字节，因此在存储小的整数时，Protobuf 比其他固定长度编码方式（如 32 位或 64 位的整数）节省了大量空间。</p>

<p>灵活性：varint 可以动态调整字节数，使得编码更适合不同大小的整数值。</p>

<p>高效：对于大部分常见的数值，Protobuf 的 varint 编码方式相对高效，尤其是在数值较小的时候。</p>

<h2 id="总结">总结</h2>

<p>Protobuf 的 varint 编码 通过将整数拆分为多个 7 位块，使用高位标记（0x80）来指示是否有更多字节，从而实现了压缩存储。</p>

<p>对于较小的整数，varint 格式非常节省空间，只有需要更多字节时才会增加开销。</p>

<p>这种编码方式非常适合序列化整数类型，尤其在处理大量小数字时能够显著减少存储空间。</p>

<p>参考文档：
https://protobuf.dev/programming-guides/encoding/</p>

<script src="https://giscus.app/client.js" data-repo="wtopps/wtopps.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnk2NzY3NTA3MA==" data-category="Comments" data-category-id="DIC_kwDOBAijvs4CizS6" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async="">
</script>]]></content><author><name>GitHub User</name></author><category term="Others" /><category term="Serialization" /><summary type="html"><![CDATA[]]></summary></entry></feed>