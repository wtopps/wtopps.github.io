<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>MySQL慢SQL探究 | wtopps</title>
<meta name="generator" content="Jekyll v4.3.4">
<meta property="og:title" content="MySQL慢SQL探究">
<meta name="author" content="GitHub User">
<meta property="og:locale" content="en_US">
<meta name="description" content="前言 我们在日常开发中，一定遇见过某些SQL执行较慢的情况，我们俗称“慢SQL”，如果你对系统的接口性能要求较高的话，一定不会放过这种SQL，肯定会想办法进行解决，那么，导致慢SQL出现的原因，究竟可能都有哪些呢？ 这是一道经典的面试题，就此我们来研究一番，下面，我们就来好好看一下，原因可能出在哪里。 本篇我们将从如下几个方面进行讨论： 1、慢SQL捕获 2、执行计划分析 3、引擎参数配置分析 让我们就此开启本次慢SQL分析之旅，Let’s go！ ps: 本篇文章的讨论，主要基于MySQL8.0数据库，Oracle等其他数据库不在本篇讨论范围之列。 1、慢SQL捕获 追查应用服务的慢SQL，首先需要追踪哪些SQL可能是慢SQL，对于Java服务，很多数据库中间件提供了慢SQL的追踪能力，例如Alibaba Druid，会将服务运行过程中的慢SQL打印到日志文件，方便开发运维人员追查。 MySQL当然也提供了捕获慢查询的监控能力，记录在MySQL中执行时间超过指定时间的SQL语句。 默认情况下，MySQL 并没有开启慢日志，可以通过修改 slow_query_log 参数来打开慢日志。与慢日志相关的参数介绍如下： slow_query_log：是否启用慢查询日志，1表示开启，0表示关闭，默认为关闭。 slow_query_log_file：指定慢查询日志位置及名称，默认值为host_name-slow.log，可指定绝对路径。 long_query_time：慢查询执行时间阈值，超过此时间会记录，默认为10，取值范围0~31536000，单位为秒。 min_examined_row_limit：对于查询扫描行数小于此参数的SQL，将不会记录到慢查询日志中，默认为0，最大值(bit-64)为18446744073709551615。 log_output：慢查询日志输出目标，默认为FILE，即输出到文件，取值为TABLE、FILE、NONE。 log_timestamps：主要是控制 error log、slow log、genera log 日志文件中的显示时区，默认使用UTC时区，取值为UTC、SYSTEM，建议改为 SYSTEM 系统时区。 log_queries_not_using_indexes：是否记录所有未使用索引的查询语句，默认为OFF。 log_slow_admin_statements：慢速管理语句是否写入慢日志中，管理语句包含 ALTER TABLE, ANALYZE TABLE, CHECK TABLE, CREATE INDEX, DROP INDEX, OPTIMIZE TABLE, REPAIR TABLE，默认为 OFF 即不写入。 一般情况下，我们只需开启慢日志记录，配置下阈值时间，其余参数可按默认配置。对于阈值时间，可灵活调整，比如说可以设置为 1s 或 3s 。 慢查询追踪配置方式 MySQL提供了两种配置慢查询参数的方式，提供给开发者使用，下面我们依次来看一下。 第一种，将慢查询参数配置写入 MySQL 配置文件，永久生效 # 慢查询日志相关配置，可根据实际情况修改 vim /etc/my.cnf [mysqld] slow_query_log = 1 slow_query_log_file = /var/log/mysql/sql-slow.log long_query_time = 1 log_timestamps = SYSTEM log_output = FILE 第二种，MySQL Server 中临时开启慢查询功能，当 MySQL Server 重启时，配置修改则全部失效并恢复原状 SET GLOBAL slow_query_log = 'ON'; SET GLOBAL slow_query_log_file = '/var/log/mysql/sql-slow.log'; SET GLOBAL log_queries_not_using_indexes = 'ON'; SET SESSION long_query_time = 1; SET SESSION min_examined_row_limit = 100; 下面我们具体看下，慢日志会记录哪些内容？我们执行一条较慢的查询 SQL ，来看下在慢日志中的体现。 # Time: 2022-11-02T09:23:37.004885Z # User@Host: wtopps[wtopps] @ localhost [] Id: 10831 # Query_time: 1.609214 Lock_time: 0.003828 Rows_sent: 2050008 Rows_examined: 2150010 SET timestamp=1667381015; SELECT A.* FROM `user` A LEFT JOIN grade B ON A.`id` = B.`user_id`; 对于每一组慢SQL，日志内容格式如下： 第一行记录的是该条 SQL 执行的时刻（如果 log_timestamps 参数为 UTC ，则改时间会显示 UTC 时区时间） 第二行记录的是执行该语句的用户和 IP 以及链接 id 第三行的几个字段含义如下： Query_time：语句执行时间，以秒为单位。 Lock_time：获取锁的时间(以秒为单位)。 Rows_sent：发送给 Client 端的行数。 Rows_examined：服务器层检查的行数(不计算存储引擎内部的任何处理) 通过慢查询日志，我们可以捕获到具体的慢SQL，接下来，则要具体分析慢SQL产生的可能原因。 2、情况分析 为什么查询会慢？ 在尝试编写快速的查询之前，需要清楚一点，真正重要是响应时间。如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。 MySQL在执行查询的时候有哪些子任务，哪些子任务运行的速度很慢？这里很难给出完整的列表，通常来说，查询的生命周期大致可以按照顺序来看： 从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。 在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。 根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。 在每一个消耗大量时间的查询案例中，大概率会出现一些不必要的额外操作、某些操作被额外地重复了很多次、某些操作执行得太慢等。优化查询的目的就是减少和消除这些操作所花费的时间。 再次申明一点，对于一个查询的全部生命周期，上面列的并不完整。这里我们只是想说明：了解查询的生命周期、清楚查询的时间消耗情况对于优化查询有很大的意义。有了这些概念，我们再一起来看看如何优化查询。 捕获具体的慢查询SQL后，我们需要对可能导致慢查询的原因进行分析，我们可以从如下几个角度，对问题进行拆解： SQL执行计划分析 引擎参数配置分析 引擎参数配置分析（网络，物理机配置，内存，机器负载I/O） 2.1 SQL执行计划分析 查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免地需要筛选大量数据，但在实际业务场景中，这并不常见。 大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效： 1．确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。 2．确认MySQL服务器层是否在分析大量超过需要的数据行。 有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU 和内存资源。 因此，合理的使用索引的重要性就凸显出来，如果查询中的查询条件未命中索引字段，MySQL引擎则只能对全量的数据进行检索，再根据查询条件进行过滤，筛选出目标的数据集，这个过程是非常耗时且低效的。 接下来，我们将逐步对SQL执行的过程进行分析拆解，通过工具手段剖析慢查询的具体原因。 explain执行计划分析 对于SQL执行过程分析，最先登场的毫无疑问就是 explain语句了， explain是我们在日常开发最常使用的分析命令。其使用方式，这里不再赘述，一般来说，95% 的慢查询问题只需要 explain 就可以解决了。 对于explain执行计划的分析，我们需要关注最简单的衡量查询开销的两个点： 扫描的行数 返回的行数 通过explain执行计划可以获得SQL在执行时预估的扫描行数以及返回行数的大概比例，这在一定程度上能够说明该查询找到需要的数据的效率高不高。 但这个指标也并不是绝对的，因为并不是所有的行的访问代价都是相同的。较短的行的访问速度更快，内存中的行也比磁盘中的行的访问速度要，快得多。 理想情况下扫描的行数和返回的行数应该是相同的。但实际情况中这种情况并不多见。 例如在做一个多表的join关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1：1和10：1之间，不过有时候这个值也可能非常非常大。 比值越大则意味着查询效率越低，因为引擎执行扫描出的大部分数据行都会被丢弃，这也意味着需要执行更多的I/O操作，因此尽可能降低扫描的行数对返回的行数的比率，是我们对慢查询优化的关键所在。 一般MySQL 能够使用如下三种方式应用where条件，从好到坏依次为： 在索引中使用where条件来过滤不匹配的记录。这是在存储引擎层完成的。 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。 Extra中Using Index与Using Where，MySQL官方文档的解释如下： Using Index The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. This strategy can be used when the query uses only columns that are part of a single index. Using Where A WHERE clause is used to restrict which rows to match against the next table or send to the client. Unless you specifically intend to fetch or examine all rows from the table, you may have something wrong in your query if the Extra value is not Using where and the table join type is ALL or index. 使用explain判断导致查询慢的原因，判断依据可以根据如下几点： where查询条件中的字段，是否是索引字段，索引字段是否满足了最左匹配原则 where查询条件中是否对索引字段使用了函数处理 对索引字段使用函数操作，会使得索引失效 where查询条件中是否存在like %字段% 情况 like %%的全模糊匹配，会使得索引失效，如需使用like，请使用like 字段% 对于select *的查询，该表的字段数量为多少 对于巨型宽表，例如上百个字段的大表，select * 是效率低下的选择，实际业务中很少有情况会需要全部字段的情况，根据需要查询特定的字段是非常必要的 where查询条件中是否使用or，如果使用了，or的字段是否是主键或者索引字段 对于主键或索引字段，or与in不存在性能差距，对于非索引字段，or的性能会低于in In many database servers, IN() is just a synonym for multiple OR clauses, because the two are logically equivalent. Not so in MySQL, which sorts the values in the IN() list and uses a fast binary search to see whether a value is in the list. This is O(Log n) in the size of the list, whereas an equivalent series of OR clauses is O(n) in the size of the list (i.e., much slower for large lists) 查询是否使用了多个表(大于3张) 的join操作，join表的数据量级如何，是否使用了索引字段进行查询 对于多表join的复杂联合查询，是可能产生慢SQL的重灾区，join子表的顺序决定了扫描结果集会有多大，需要结合explain进行分析判断 实际业务场景中，也尽可能的避免多表join操作，需要在表设计阶段就做好冗余字段的考虑 where查询条件是否使用了分页查询，分页深度是多大 limit 10, offset 100000，MySQL在实际执行时，会查询出100010条记录，然后丢弃前100000条，性能会极为的糟糕 对于深分页查询优化，当执行深度分页时，可以带入主键ID作为查询条件，执行下一页的查询时，将上一页最大的主键ID作为条件，id &gt; last_page_max_id 综上我们总结，SQL执行时其扫描的行数决定了执行的效率，而决定扫描行数的关键，则是索引的命中情况与索引的质量。 Tips:关于索引的一些小建议 1、唯一索引命名uk字段，普通索引命名idx字段，过长时可用首字母替代 2、尽量避免三张表以上的join，对于多表join的情况，可以视情况考虑将一个大查询拆分成多个子查询，对结果集在业务层进行聚合处理。如必须要多表join的场景，特别注意多连表查询的扫描行数问题以及索引的命中情况。 3、varchar长字段建立索引，需要指定索引长度，根据文本区分度来决定长度。 4、避免左模糊，全模糊匹配。 5、order by 字段放在索引最后列，避免filesort 6、考虑利用覆盖索引来进行查询操作，避免回表 7、性能优化目标，需要为range级别以上，最好是ref级别，或者const最好。 8、区分度高的列在索引最左边。 9、避免字段类型不同造成的隐式转换，导致索引失效。例如：varchar和数字类型 10、根据大多数SQL来创建索引。 11、对于运行较久的大表，需要关注索引字段的区分度问题，当索引值出现了严重倾斜时，需要考虑优化拆分索引值。 PROFILE分析 通过使用explain分析SQL的执行计划，我们可以看到SQL执行过程中是否使用索引，使用了哪些索引，索引扫描的行数等，但MySQL的慢查询，并不一定慢在有没有索引，SQL的执行环节中任意一环出了问题都会表现为查询变慢，所以即使执行过程命中了索引，explain的结果也很完美，但是还是慢，怎么办？ 这时候，就需要profile工具来帮忙了，这个命令可以详细的列出 SQL 语句在每一个步骤消耗的时间，前提（缺点）是先执行一遍语句。 PROFILE 默认是关闭的，所以需要在client端先打开，操作如下： set session profiling = 1; 在实际的生产环境中，可能会需要加大profile的队列，保证想要查看的 profile结果还保存着，因此可以用如下操作来增加profile的队列大小： set session profiling_history_size = 50; 让我们一起来看一下profile分析如何使用，我们先执行下面的SQL： mysql&gt; explain select * from user where name = '小六' and code = 300000003; +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ | 1 | SIMPLE | user | NULL | ALL | NULL | NULL | NULL | NULL | 2043040 | 1.00 | Using where | +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) 这个一个典型的效果较差的查询，type=ALL，没有命中索引，执行了全表扫描，我们使用profile分析一下各阶段的执行时间： mysql&gt; show profiles; +----------+------------+---------------------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+---------------------------------------------------------------+ | 1 | 0.55695825 | select * from user where name = '小六' and code = 300000003 | +----------+------------+---------------------------------------------------------------+ 1 row in set, 1 warning (0.00 sec) 找到我们需要分析的语句，查询执行耗时详情： mysql&gt; show profile block io,cpu,memory,source for query 1; 从profile执行结果中，我们可以清晰的看到一条SQL在每个执行阶段的耗时、CPU使用率、IO等指标，帮助我们定位到慢查询具体执行耗时的阶段，对于该条SQL，执行过程中最耗时的部分是executing部分，executing阶段包括了执行线程正在为SELECT读取和处理数据行，并将数据发送到客户端。因为在这个状态下发生的操作往往执行大量的磁盘读取，所以它往往是在整个查询的生命周期中运行时间最长的一个阶段。 经过了对SQL语句进行explain与profile分析之后，一个 SQL 为什么慢，慢在哪里基本上可以定位出来了，那么最后的手段主要是解决什么问题呢？ 我们将使用最终的分析工具，OPTIMIZER_TRACE。 OPTIMIZER_TRACE分析 OPTIMIZER_TRACE 是 MySQL 5.6 添加的新功能，这个功能可以看到内部查询计划的 TRACE 信息，也就是MySQL在执行过程中的具体决策细节，从而可以知道 MySQL 是如何在众多索引中的挑选最合适的索引。 如果我们通过执行计划，发现MySQL选择的索引并不符合我们的预期，就需要根据 OPTIMIZER_TRACE 的信息来判断为什么会选择它，是 MySQL 的配置原因，还是 SQL 某些地方写的不好导致 MySQL 误判。 开启这个功能的方式如下： set session optimizer_trace='enabled=on'; 在客户端执行一个EXPLAIN语句，生成一个执行计划，然后在information_chema.optimizer_trace的表里面查找这一条语句对应的信息： mysql&gt; select * from information_schema.optimizer_trace; | explain select * from user where age = 21 | { &quot;steps&quot;: [ { &quot;join_preparation&quot;: { &quot;select#&quot;: 1, &quot;steps&quot;: [ { &quot;expanded_query&quot;: &quot;/* select#1 */ select `user`.`id` AS `id`,`user`.`name` AS `name`,`user`.`age` AS `age`,`user`.`code` AS `code` from `user` where (`user`.`age` = 21)&quot; } ] } }, { &quot;join_optimization&quot;: { &quot;select#&quot;: 1, &quot;steps&quot;: [ { &quot;condition_processing&quot;: { &quot;condition&quot;: &quot;WHERE&quot;, &quot;original_condition&quot;: &quot;(`user`.`age` = 21)&quot;, &quot;steps&quot;: [ { &quot;transformation&quot;: &quot;equality_propagation&quot;, &quot;resulting_condition&quot;: &quot;multiple equal(21, `user`.`age`)&quot; }, { &quot;transformation&quot;: &quot;constant_propagation&quot;, &quot;resulting_condition&quot;: &quot;multiple equal(21, `user`.`age`)&quot; }, { &quot;transformation&quot;: &quot;trivial_condition_removal&quot;, &quot;resulting_condition&quot;: &quot;multiple equal(21, `user`.`age`)&quot; } ] } }, { &quot;substitute_generated_columns&quot;: { } }, { &quot;table_dependencies&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;row_may_be_null&quot;: false, &quot;map_bit&quot;: 0, &quot;depends_on_map_bits&quot;: [ ] } ] }, { &quot;ref_optimizer_key_uses&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;field&quot;: &quot;age&quot;, &quot;equals&quot;: &quot;21&quot;, &quot;null_rejecting&quot;: true } ] }, { &quot;rows_estimation&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;range_analysis&quot;: { &quot;table_scan&quot;: { &quot;rows&quot;: 2043040, &quot;cost&quot;: 205676 }, &quot;potential_range_indexes&quot;: [ { &quot;index&quot;: &quot;PRIMARY&quot;, &quot;usable&quot;: false, &quot;cause&quot;: &quot;not_applicable&quot; }, { &quot;index&quot;: &quot;idx_age&quot;, &quot;usable&quot;: true, &quot;key_parts&quot;: [ &quot;age&quot;, &quot;id&quot; ] } ], &quot;setup_range_conditions&quot;: [ ], &quot;group_index_range&quot;: { &quot;chosen&quot;: false, &quot;cause&quot;: &quot;not_group_by_or_distinct&quot; }, &quot;skip_scan_range&quot;: { &quot;potential_skip_scan_indexes&quot;: [ { &quot;index&quot;: &quot;idx_age&quot;, &quot;usable&quot;: false, &quot;cause&quot;: &quot;query_references_nonkey_column&quot; } ] }, &quot;analyzing_range_alternatives&quot;: { &quot;range_scan_alternatives&quot;: [ { &quot;index&quot;: &quot;idx_age&quot;, &quot;ranges&quot;: [ &quot;21 &lt;= age &lt;= 21&quot; ], &quot;index_dives_for_eq_ranges&quot;: true, &quot;rowid_ordered&quot;: true, &quot;using_mrr&quot;: false, &quot;index_only&quot;: false, &quot;in_memory&quot;: 0.788627, &quot;rows&quot;: 1, &quot;cost&quot;: 0.61, &quot;chosen&quot;: true } ], &quot;analyzing_roworder_intersect&quot;: { &quot;usable&quot;: false, &quot;cause&quot;: &quot;too_few_roworder_scans&quot; } }, &quot;chosen_range_access_summary&quot;: { &quot;range_access_plan&quot;: { &quot;type&quot;: &quot;range_scan&quot;, &quot;index&quot;: &quot;idx_age&quot;, &quot;rows&quot;: 1, &quot;ranges&quot;: [ &quot;21 &lt;= age &lt;= 21&quot; ] }, &quot;rows_for_plan&quot;: 1, &quot;cost_for_plan&quot;: 0.61, &quot;chosen&quot;: true } } } ] }, { &quot;considered_execution_plans&quot;: [ { &quot;plan_prefix&quot;: [ ], &quot;table&quot;: &quot;`user`&quot;, &quot;best_access_path&quot;: { &quot;considered_access_paths&quot;: [ { &quot;access_type&quot;: &quot;ref&quot;, &quot;index&quot;: &quot;idx_age&quot;, &quot;rows&quot;: 1, &quot;cost&quot;: 0.35, &quot;chosen&quot;: true }, { &quot;access_type&quot;: &quot;range&quot;, &quot;range_details&quot;: { &quot;used_index&quot;: &quot;idx_age&quot; }, &quot;chosen&quot;: false, &quot;cause&quot;: &quot;heuristic_index_cheaper&quot; } ] }, &quot;condition_filtering_pct&quot;: 100, &quot;rows_for_plan&quot;: 1, &quot;cost_for_plan&quot;: 0.35, &quot;chosen&quot;: true } ] }, { &quot;attaching_conditions_to_tables&quot;: { &quot;original_condition&quot;: &quot;(`user`.`age` = 21)&quot;, &quot;attached_conditions_computation&quot;: [ ], &quot;attached_conditions_summary&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;attached&quot;: &quot;(`user`.`age` = 21)&quot; } ] } }, { &quot;finalizing_table_conditions&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;original_table_condition&quot;: &quot;(`user`.`age` = 21)&quot;, &quot;final_table_condition &quot;: null } ] }, { &quot;refine_plan&quot;: [ { &quot;table&quot;: &quot;`user`&quot; } ] } ] } }, { &quot;join_explain&quot;: { &quot;select#&quot;: 1, &quot;steps&quot;: [ ] } } ] } 1 row in set (0.02 sec) 内容是非常长的 JSON 格式，所以推荐把结果转存到其他地方，然后用 JSON 的转换工具来辅助查看，如果要看索引的选择情况，就重点关注这个 JSON 的ref_optimizer_key_uses，rows_estimation 及之后的部分，这里会展示索引选择相关的信息，截取一部分结果作为示例： { &quot;ref_optimizer_key_uses&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;field&quot;: &quot;age&quot;, &quot;equals&quot;: &quot;21&quot;, &quot;null_rejecting&quot;: true } ] } ...... &quot;chosen_range_access_summary&quot;: { &quot;range_access_plan&quot;: { &quot;type&quot;: &quot;range_scan&quot;, &quot;index&quot;: &quot;idx_age&quot;, &quot;rows&quot;: 1, &quot;ranges&quot;: [ &quot;21 &lt;= age &lt;= 21&quot; ] }, &quot;rows_for_plan&quot;: 1, &quot;cost_for_plan&quot;: 0.61, &quot;chosen&quot;: true } 3、引擎参数配置分析 上面的篇幅中，我们针对SQL层面进行了可能导致慢查询的原因分析，MySQL的数据最终都会存储在磁盘上，因此操作系统的I/O情况也会影响MySQL的运行性能，这一章节我们将从底层入手，从操作系统I/O层面分析MySQL执行性能问题。 I/O性能分析 Linux系统查看系统I/O情况，可以使用iostat命令： [root@VM-16-14-centos ~]# iostat -x 1 -m Linux 3.10.0-1160.11.1.el7.x86_64 (VM-16-14-centos) 12/21/2022 _x86_64_ (1 CPU) avg-cpu: %user %nice %system %iowait %steal %idle 0.82 0.00 0.67 0.07 0.00 98.44 Device: rrqm/s wrqm/s r/s w/s rMB/s wMB/s avgrq-sz avgqu-sz await r_await w_await svctm %util vda 0.00 1.67 0.04 2.49 0.00 0.02 17.55 0.01 2.34 3.74 2.31 0.29 0.07 scd0 0.00 0.00 0.00 0.00 0.00 0.00 7.10 0.00 0.89 0.89 0.00 0.88 0.00 avg-cpu 自然就是 CPU 相关的指标，判断 IO 问题时可以关注 %iowait，其他指标的意义如下： r/s 和 w/s：合并过后的读请求和写请求的每秒请求数，可以当做 IOPS 来理解。 rMB/s 和 wMB/s：磁盘的读写吞吐量。 rrqm/s 和 wrqm/s：每秒合并的读请求和写请求数量。 r_await 和 w_await：读请求和写请求的平均响应时间，包含真正的处理时间和队列中的等待时间（ms）。 avgrq-sz：平均每次设备I/O操作的数据大小 (扇区)。 avgqu-sz：平均I/O队列长度。 await：平均每次设备I/O操作的等待时间 (毫秒)。 scvtm：计算出来的平均 IO 响应时间，目前已经不准确，不用再关注。 %util：如果使用了 RAID 或者 SSD，则忽略这个指标，仅在单块机械盘上准确。 一般来说，评价一块 IO 设备（忽略机械盘的情况，没有评价的意义）是否达到了高负载情况，可以看这几个指标：r/s，w/s，rMB/s，wMB/s，r_await，w_await，avgqu-sz。 MySQL I/O参数 MySQL 涉及到 IO 相关的参数会比较多，因此这里仅一部分经常用到的参数： 参数 默认设置 备注 innodb_io_capacity 200 定义了后台任务可用的 IOPS 量，InnoDB后台任务可用的每秒I/O操作数（IOPS），例如从缓冲池冲刷页面和从变更缓冲区合并数据。 innodb_io_capacity_max 动态 定义了后台任务可用的最大 IOPS 量 innodb_flush_log_at_trx_commit 1 控制事务的提交策略 0：日志缓存区将每隔一秒写到日志文件中，并且将日志文件的数据刷新到磁盘上。该模式下在事务提交时不会主动触发写入磁盘的操作。 1：每次事务提交时RDS for MySQL都会把日志缓存区的数据写入日志文件中，并且刷新到磁盘中，该模式为系统默认。 2：每次事务提交时RDS for MySQL都会把日志缓存区的数据写入日志文件中，但是并不会同时刷新到磁盘上。该模式下，MySQL会每秒执行一次刷新磁盘操作。 sync_binlog 1 控制 binlog 落盘的频率0 ：存储引擎不进行binlog的刷新到磁盘，而由操作系统的文件系统控制缓存刷新。1：每提交一次事务，存储引擎调用文件系统的sync操作进行一次缓存的刷新，这种方式最安全，但性能较低。n：在每N次binlog日志文件写入后与磁盘同步，存储引擎调用文件系统的sync操作进行一次缓存的刷新。 innodb_io_capacity 和 innodb_io_capacity_max 是最直接限制 IOPS 的指标，大多数时候，SSD 可以设置成 16000 或者更高的数值，如果是云主机或者其他的共享存储设备，则需要了解一下详细的 IOPS 上限再具体调整。 trx_commit 和 sync_binlog 这两个参数也放进来的原因是不同的参数组合对 IO 的压力也会有区别。 通常的用法是双 1 或者 20（二零），参考官方文档的描述，双 1 在每次提交事务的时候都会刷盘，对 IO 的压力要高不少； 20 则是滞后刷盘，对 IO 的压力会较小，因此写入 QPS 会高一些。 另外，可以关注到一个细节，innodb_io_capacity 的描述对象是：后台任务。这代表着 MySQL 后台的 flush，purge 操作会受到这个参数设置的限制。 吞吐量和 IOPS ，一般情况下衡量 IO 系统性能最直观的指标，并没有特别的提及，主要原因还是判断起来很简单：如果iostat的指标已经达到或者接近了实际硬件的指标（比如达到了 75%），那么根据业务量增长的情况及早规划硬件升级或者其他的手段来分散读写压力。 常规的手段，可以简单的遵循以下场景来酌情使用：读多写少读写分离，写多读少拆库拆表加缓存。 其他原因分析 网络抖动 目前的互联网应用服务，数据库的部署与应用服务的部署，不会在一台服务器上，那么应用服务器与数据库服务器之间就需要通过网络通信，一般情况来讲，都会在同机房或同一个可用区进行部署，以保证网络通信的质量。 但是难免可能会出现网络抖动的情况，这种情况下，对应用服务来讲，可能会出现一条SQL执行较慢的情况，但不是由于数据库原因导致的，而是由于网络原因导致的。 发现偶现的SQL执行慢，且SQL本身执行计划没有问题，可以从网络的角度分析问题，在服务所在的机器ping数据库服务器，查看响应时间，特别针对数据库服务器与业务服务器跨城市的情况，如果没有拉通专线访问，会很容易出现网络慢导致的问题。 单表数据量过大 上面我们提到了InnoDB的数据存储方式是面向主键索引进行数据存储的。 InnoDB的数据表数量级超过几千万后，性能会出现下降，核心是由于B+Tree的数据结构导致的。 因此，当你的数据表超过几千万量级的时候，SQL执行即使全部命中的索引，也有可能出现执行慢的情况。 这个时候，建议考虑采用拆表。目前开源的优秀的分库分表中间件有很多，例如sharing-JDBC、MyCat等，可以根据业务的实际情况进行选择，这里就不过多的进行赘述。 总结 本篇，我们围绕着一个问题：一条SQL执行较慢可能有哪些原因导致的？ 进行了研究，总结一下，大部分的慢查询其实均由SQL书写不当导致的，通过explain命令结合实际业务场景分析，可以解决绝大多数的慢查询问题，对于一些疑难杂症SQL，使用MySQL强大的SQL分析工具，也可以找出真正的问题原因。 另外，系统层面的分析也是必不可少的，作为开发人员，我们也需要掌握一些DBA的分析手段，检查MySQL运行性能情况，保证数据库服务的稳定运行。 本篇参考： MySQL官方文档The Slow Query Log： https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_long_query_time https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information mysql or/in性能对比： https://www.cnblogs.com/chihirotan/p/7457204.html MySQL explain结果Extra中”Using Index”与”Using where; Using index”区别探究： https://www.cnblogs.com/AcAc-t/p/mysql_explain_difference_between_using_index_and_using_where.html MySQL General Thread States： https://dev.mysql.com/doc/refman/8.0/en/general-thread-states.html innodb_flush_log_at_trx_commit和sync_binlog参数详解： https://support.huaweicloud.com/bestpractice-rds/rds_02_0010.html">
<meta property="og:description" content="前言 我们在日常开发中，一定遇见过某些SQL执行较慢的情况，我们俗称“慢SQL”，如果你对系统的接口性能要求较高的话，一定不会放过这种SQL，肯定会想办法进行解决，那么，导致慢SQL出现的原因，究竟可能都有哪些呢？ 这是一道经典的面试题，就此我们来研究一番，下面，我们就来好好看一下，原因可能出在哪里。 本篇我们将从如下几个方面进行讨论： 1、慢SQL捕获 2、执行计划分析 3、引擎参数配置分析 让我们就此开启本次慢SQL分析之旅，Let’s go！ ps: 本篇文章的讨论，主要基于MySQL8.0数据库，Oracle等其他数据库不在本篇讨论范围之列。 1、慢SQL捕获 追查应用服务的慢SQL，首先需要追踪哪些SQL可能是慢SQL，对于Java服务，很多数据库中间件提供了慢SQL的追踪能力，例如Alibaba Druid，会将服务运行过程中的慢SQL打印到日志文件，方便开发运维人员追查。 MySQL当然也提供了捕获慢查询的监控能力，记录在MySQL中执行时间超过指定时间的SQL语句。 默认情况下，MySQL 并没有开启慢日志，可以通过修改 slow_query_log 参数来打开慢日志。与慢日志相关的参数介绍如下： slow_query_log：是否启用慢查询日志，1表示开启，0表示关闭，默认为关闭。 slow_query_log_file：指定慢查询日志位置及名称，默认值为host_name-slow.log，可指定绝对路径。 long_query_time：慢查询执行时间阈值，超过此时间会记录，默认为10，取值范围0~31536000，单位为秒。 min_examined_row_limit：对于查询扫描行数小于此参数的SQL，将不会记录到慢查询日志中，默认为0，最大值(bit-64)为18446744073709551615。 log_output：慢查询日志输出目标，默认为FILE，即输出到文件，取值为TABLE、FILE、NONE。 log_timestamps：主要是控制 error log、slow log、genera log 日志文件中的显示时区，默认使用UTC时区，取值为UTC、SYSTEM，建议改为 SYSTEM 系统时区。 log_queries_not_using_indexes：是否记录所有未使用索引的查询语句，默认为OFF。 log_slow_admin_statements：慢速管理语句是否写入慢日志中，管理语句包含 ALTER TABLE, ANALYZE TABLE, CHECK TABLE, CREATE INDEX, DROP INDEX, OPTIMIZE TABLE, REPAIR TABLE，默认为 OFF 即不写入。 一般情况下，我们只需开启慢日志记录，配置下阈值时间，其余参数可按默认配置。对于阈值时间，可灵活调整，比如说可以设置为 1s 或 3s 。 慢查询追踪配置方式 MySQL提供了两种配置慢查询参数的方式，提供给开发者使用，下面我们依次来看一下。 第一种，将慢查询参数配置写入 MySQL 配置文件，永久生效 # 慢查询日志相关配置，可根据实际情况修改 vim /etc/my.cnf [mysqld] slow_query_log = 1 slow_query_log_file = /var/log/mysql/sql-slow.log long_query_time = 1 log_timestamps = SYSTEM log_output = FILE 第二种，MySQL Server 中临时开启慢查询功能，当 MySQL Server 重启时，配置修改则全部失效并恢复原状 SET GLOBAL slow_query_log = 'ON'; SET GLOBAL slow_query_log_file = '/var/log/mysql/sql-slow.log'; SET GLOBAL log_queries_not_using_indexes = 'ON'; SET SESSION long_query_time = 1; SET SESSION min_examined_row_limit = 100; 下面我们具体看下，慢日志会记录哪些内容？我们执行一条较慢的查询 SQL ，来看下在慢日志中的体现。 # Time: 2022-11-02T09:23:37.004885Z # User@Host: wtopps[wtopps] @ localhost [] Id: 10831 # Query_time: 1.609214 Lock_time: 0.003828 Rows_sent: 2050008 Rows_examined: 2150010 SET timestamp=1667381015; SELECT A.* FROM `user` A LEFT JOIN grade B ON A.`id` = B.`user_id`; 对于每一组慢SQL，日志内容格式如下： 第一行记录的是该条 SQL 执行的时刻（如果 log_timestamps 参数为 UTC ，则改时间会显示 UTC 时区时间） 第二行记录的是执行该语句的用户和 IP 以及链接 id 第三行的几个字段含义如下： Query_time：语句执行时间，以秒为单位。 Lock_time：获取锁的时间(以秒为单位)。 Rows_sent：发送给 Client 端的行数。 Rows_examined：服务器层检查的行数(不计算存储引擎内部的任何处理) 通过慢查询日志，我们可以捕获到具体的慢SQL，接下来，则要具体分析慢SQL产生的可能原因。 2、情况分析 为什么查询会慢？ 在尝试编写快速的查询之前，需要清楚一点，真正重要是响应时间。如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。 MySQL在执行查询的时候有哪些子任务，哪些子任务运行的速度很慢？这里很难给出完整的列表，通常来说，查询的生命周期大致可以按照顺序来看： 从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。 在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。 根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。 在每一个消耗大量时间的查询案例中，大概率会出现一些不必要的额外操作、某些操作被额外地重复了很多次、某些操作执行得太慢等。优化查询的目的就是减少和消除这些操作所花费的时间。 再次申明一点，对于一个查询的全部生命周期，上面列的并不完整。这里我们只是想说明：了解查询的生命周期、清楚查询的时间消耗情况对于优化查询有很大的意义。有了这些概念，我们再一起来看看如何优化查询。 捕获具体的慢查询SQL后，我们需要对可能导致慢查询的原因进行分析，我们可以从如下几个角度，对问题进行拆解： SQL执行计划分析 引擎参数配置分析 引擎参数配置分析（网络，物理机配置，内存，机器负载I/O） 2.1 SQL执行计划分析 查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免地需要筛选大量数据，但在实际业务场景中，这并不常见。 大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效： 1．确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。 2．确认MySQL服务器层是否在分析大量超过需要的数据行。 有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU 和内存资源。 因此，合理的使用索引的重要性就凸显出来，如果查询中的查询条件未命中索引字段，MySQL引擎则只能对全量的数据进行检索，再根据查询条件进行过滤，筛选出目标的数据集，这个过程是非常耗时且低效的。 接下来，我们将逐步对SQL执行的过程进行分析拆解，通过工具手段剖析慢查询的具体原因。 explain执行计划分析 对于SQL执行过程分析，最先登场的毫无疑问就是 explain语句了， explain是我们在日常开发最常使用的分析命令。其使用方式，这里不再赘述，一般来说，95% 的慢查询问题只需要 explain 就可以解决了。 对于explain执行计划的分析，我们需要关注最简单的衡量查询开销的两个点： 扫描的行数 返回的行数 通过explain执行计划可以获得SQL在执行时预估的扫描行数以及返回行数的大概比例，这在一定程度上能够说明该查询找到需要的数据的效率高不高。 但这个指标也并不是绝对的，因为并不是所有的行的访问代价都是相同的。较短的行的访问速度更快，内存中的行也比磁盘中的行的访问速度要，快得多。 理想情况下扫描的行数和返回的行数应该是相同的。但实际情况中这种情况并不多见。 例如在做一个多表的join关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1：1和10：1之间，不过有时候这个值也可能非常非常大。 比值越大则意味着查询效率越低，因为引擎执行扫描出的大部分数据行都会被丢弃，这也意味着需要执行更多的I/O操作，因此尽可能降低扫描的行数对返回的行数的比率，是我们对慢查询优化的关键所在。 一般MySQL 能够使用如下三种方式应用where条件，从好到坏依次为： 在索引中使用where条件来过滤不匹配的记录。这是在存储引擎层完成的。 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。 Extra中Using Index与Using Where，MySQL官方文档的解释如下： Using Index The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. This strategy can be used when the query uses only columns that are part of a single index. Using Where A WHERE clause is used to restrict which rows to match against the next table or send to the client. Unless you specifically intend to fetch or examine all rows from the table, you may have something wrong in your query if the Extra value is not Using where and the table join type is ALL or index. 使用explain判断导致查询慢的原因，判断依据可以根据如下几点： where查询条件中的字段，是否是索引字段，索引字段是否满足了最左匹配原则 where查询条件中是否对索引字段使用了函数处理 对索引字段使用函数操作，会使得索引失效 where查询条件中是否存在like %字段% 情况 like %%的全模糊匹配，会使得索引失效，如需使用like，请使用like 字段% 对于select *的查询，该表的字段数量为多少 对于巨型宽表，例如上百个字段的大表，select * 是效率低下的选择，实际业务中很少有情况会需要全部字段的情况，根据需要查询特定的字段是非常必要的 where查询条件中是否使用or，如果使用了，or的字段是否是主键或者索引字段 对于主键或索引字段，or与in不存在性能差距，对于非索引字段，or的性能会低于in In many database servers, IN() is just a synonym for multiple OR clauses, because the two are logically equivalent. Not so in MySQL, which sorts the values in the IN() list and uses a fast binary search to see whether a value is in the list. This is O(Log n) in the size of the list, whereas an equivalent series of OR clauses is O(n) in the size of the list (i.e., much slower for large lists) 查询是否使用了多个表(大于3张) 的join操作，join表的数据量级如何，是否使用了索引字段进行查询 对于多表join的复杂联合查询，是可能产生慢SQL的重灾区，join子表的顺序决定了扫描结果集会有多大，需要结合explain进行分析判断 实际业务场景中，也尽可能的避免多表join操作，需要在表设计阶段就做好冗余字段的考虑 where查询条件是否使用了分页查询，分页深度是多大 limit 10, offset 100000，MySQL在实际执行时，会查询出100010条记录，然后丢弃前100000条，性能会极为的糟糕 对于深分页查询优化，当执行深度分页时，可以带入主键ID作为查询条件，执行下一页的查询时，将上一页最大的主键ID作为条件，id &gt; last_page_max_id 综上我们总结，SQL执行时其扫描的行数决定了执行的效率，而决定扫描行数的关键，则是索引的命中情况与索引的质量。 Tips:关于索引的一些小建议 1、唯一索引命名uk字段，普通索引命名idx字段，过长时可用首字母替代 2、尽量避免三张表以上的join，对于多表join的情况，可以视情况考虑将一个大查询拆分成多个子查询，对结果集在业务层进行聚合处理。如必须要多表join的场景，特别注意多连表查询的扫描行数问题以及索引的命中情况。 3、varchar长字段建立索引，需要指定索引长度，根据文本区分度来决定长度。 4、避免左模糊，全模糊匹配。 5、order by 字段放在索引最后列，避免filesort 6、考虑利用覆盖索引来进行查询操作，避免回表 7、性能优化目标，需要为range级别以上，最好是ref级别，或者const最好。 8、区分度高的列在索引最左边。 9、避免字段类型不同造成的隐式转换，导致索引失效。例如：varchar和数字类型 10、根据大多数SQL来创建索引。 11、对于运行较久的大表，需要关注索引字段的区分度问题，当索引值出现了严重倾斜时，需要考虑优化拆分索引值。 PROFILE分析 通过使用explain分析SQL的执行计划，我们可以看到SQL执行过程中是否使用索引，使用了哪些索引，索引扫描的行数等，但MySQL的慢查询，并不一定慢在有没有索引，SQL的执行环节中任意一环出了问题都会表现为查询变慢，所以即使执行过程命中了索引，explain的结果也很完美，但是还是慢，怎么办？ 这时候，就需要profile工具来帮忙了，这个命令可以详细的列出 SQL 语句在每一个步骤消耗的时间，前提（缺点）是先执行一遍语句。 PROFILE 默认是关闭的，所以需要在client端先打开，操作如下： set session profiling = 1; 在实际的生产环境中，可能会需要加大profile的队列，保证想要查看的 profile结果还保存着，因此可以用如下操作来增加profile的队列大小： set session profiling_history_size = 50; 让我们一起来看一下profile分析如何使用，我们先执行下面的SQL： mysql&gt; explain select * from user where name = '小六' and code = 300000003; +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ | 1 | SIMPLE | user | NULL | ALL | NULL | NULL | NULL | NULL | 2043040 | 1.00 | Using where | +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) 这个一个典型的效果较差的查询，type=ALL，没有命中索引，执行了全表扫描，我们使用profile分析一下各阶段的执行时间： mysql&gt; show profiles; +----------+------------+---------------------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+---------------------------------------------------------------+ | 1 | 0.55695825 | select * from user where name = '小六' and code = 300000003 | +----------+------------+---------------------------------------------------------------+ 1 row in set, 1 warning (0.00 sec) 找到我们需要分析的语句，查询执行耗时详情： mysql&gt; show profile block io,cpu,memory,source for query 1; 从profile执行结果中，我们可以清晰的看到一条SQL在每个执行阶段的耗时、CPU使用率、IO等指标，帮助我们定位到慢查询具体执行耗时的阶段，对于该条SQL，执行过程中最耗时的部分是executing部分，executing阶段包括了执行线程正在为SELECT读取和处理数据行，并将数据发送到客户端。因为在这个状态下发生的操作往往执行大量的磁盘读取，所以它往往是在整个查询的生命周期中运行时间最长的一个阶段。 经过了对SQL语句进行explain与profile分析之后，一个 SQL 为什么慢，慢在哪里基本上可以定位出来了，那么最后的手段主要是解决什么问题呢？ 我们将使用最终的分析工具，OPTIMIZER_TRACE。 OPTIMIZER_TRACE分析 OPTIMIZER_TRACE 是 MySQL 5.6 添加的新功能，这个功能可以看到内部查询计划的 TRACE 信息，也就是MySQL在执行过程中的具体决策细节，从而可以知道 MySQL 是如何在众多索引中的挑选最合适的索引。 如果我们通过执行计划，发现MySQL选择的索引并不符合我们的预期，就需要根据 OPTIMIZER_TRACE 的信息来判断为什么会选择它，是 MySQL 的配置原因，还是 SQL 某些地方写的不好导致 MySQL 误判。 开启这个功能的方式如下： set session optimizer_trace='enabled=on'; 在客户端执行一个EXPLAIN语句，生成一个执行计划，然后在information_chema.optimizer_trace的表里面查找这一条语句对应的信息： mysql&gt; select * from information_schema.optimizer_trace; | explain select * from user where age = 21 | { &quot;steps&quot;: [ { &quot;join_preparation&quot;: { &quot;select#&quot;: 1, &quot;steps&quot;: [ { &quot;expanded_query&quot;: &quot;/* select#1 */ select `user`.`id` AS `id`,`user`.`name` AS `name`,`user`.`age` AS `age`,`user`.`code` AS `code` from `user` where (`user`.`age` = 21)&quot; } ] } }, { &quot;join_optimization&quot;: { &quot;select#&quot;: 1, &quot;steps&quot;: [ { &quot;condition_processing&quot;: { &quot;condition&quot;: &quot;WHERE&quot;, &quot;original_condition&quot;: &quot;(`user`.`age` = 21)&quot;, &quot;steps&quot;: [ { &quot;transformation&quot;: &quot;equality_propagation&quot;, &quot;resulting_condition&quot;: &quot;multiple equal(21, `user`.`age`)&quot; }, { &quot;transformation&quot;: &quot;constant_propagation&quot;, &quot;resulting_condition&quot;: &quot;multiple equal(21, `user`.`age`)&quot; }, { &quot;transformation&quot;: &quot;trivial_condition_removal&quot;, &quot;resulting_condition&quot;: &quot;multiple equal(21, `user`.`age`)&quot; } ] } }, { &quot;substitute_generated_columns&quot;: { } }, { &quot;table_dependencies&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;row_may_be_null&quot;: false, &quot;map_bit&quot;: 0, &quot;depends_on_map_bits&quot;: [ ] } ] }, { &quot;ref_optimizer_key_uses&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;field&quot;: &quot;age&quot;, &quot;equals&quot;: &quot;21&quot;, &quot;null_rejecting&quot;: true } ] }, { &quot;rows_estimation&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;range_analysis&quot;: { &quot;table_scan&quot;: { &quot;rows&quot;: 2043040, &quot;cost&quot;: 205676 }, &quot;potential_range_indexes&quot;: [ { &quot;index&quot;: &quot;PRIMARY&quot;, &quot;usable&quot;: false, &quot;cause&quot;: &quot;not_applicable&quot; }, { &quot;index&quot;: &quot;idx_age&quot;, &quot;usable&quot;: true, &quot;key_parts&quot;: [ &quot;age&quot;, &quot;id&quot; ] } ], &quot;setup_range_conditions&quot;: [ ], &quot;group_index_range&quot;: { &quot;chosen&quot;: false, &quot;cause&quot;: &quot;not_group_by_or_distinct&quot; }, &quot;skip_scan_range&quot;: { &quot;potential_skip_scan_indexes&quot;: [ { &quot;index&quot;: &quot;idx_age&quot;, &quot;usable&quot;: false, &quot;cause&quot;: &quot;query_references_nonkey_column&quot; } ] }, &quot;analyzing_range_alternatives&quot;: { &quot;range_scan_alternatives&quot;: [ { &quot;index&quot;: &quot;idx_age&quot;, &quot;ranges&quot;: [ &quot;21 &lt;= age &lt;= 21&quot; ], &quot;index_dives_for_eq_ranges&quot;: true, &quot;rowid_ordered&quot;: true, &quot;using_mrr&quot;: false, &quot;index_only&quot;: false, &quot;in_memory&quot;: 0.788627, &quot;rows&quot;: 1, &quot;cost&quot;: 0.61, &quot;chosen&quot;: true } ], &quot;analyzing_roworder_intersect&quot;: { &quot;usable&quot;: false, &quot;cause&quot;: &quot;too_few_roworder_scans&quot; } }, &quot;chosen_range_access_summary&quot;: { &quot;range_access_plan&quot;: { &quot;type&quot;: &quot;range_scan&quot;, &quot;index&quot;: &quot;idx_age&quot;, &quot;rows&quot;: 1, &quot;ranges&quot;: [ &quot;21 &lt;= age &lt;= 21&quot; ] }, &quot;rows_for_plan&quot;: 1, &quot;cost_for_plan&quot;: 0.61, &quot;chosen&quot;: true } } } ] }, { &quot;considered_execution_plans&quot;: [ { &quot;plan_prefix&quot;: [ ], &quot;table&quot;: &quot;`user`&quot;, &quot;best_access_path&quot;: { &quot;considered_access_paths&quot;: [ { &quot;access_type&quot;: &quot;ref&quot;, &quot;index&quot;: &quot;idx_age&quot;, &quot;rows&quot;: 1, &quot;cost&quot;: 0.35, &quot;chosen&quot;: true }, { &quot;access_type&quot;: &quot;range&quot;, &quot;range_details&quot;: { &quot;used_index&quot;: &quot;idx_age&quot; }, &quot;chosen&quot;: false, &quot;cause&quot;: &quot;heuristic_index_cheaper&quot; } ] }, &quot;condition_filtering_pct&quot;: 100, &quot;rows_for_plan&quot;: 1, &quot;cost_for_plan&quot;: 0.35, &quot;chosen&quot;: true } ] }, { &quot;attaching_conditions_to_tables&quot;: { &quot;original_condition&quot;: &quot;(`user`.`age` = 21)&quot;, &quot;attached_conditions_computation&quot;: [ ], &quot;attached_conditions_summary&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;attached&quot;: &quot;(`user`.`age` = 21)&quot; } ] } }, { &quot;finalizing_table_conditions&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;original_table_condition&quot;: &quot;(`user`.`age` = 21)&quot;, &quot;final_table_condition &quot;: null } ] }, { &quot;refine_plan&quot;: [ { &quot;table&quot;: &quot;`user`&quot; } ] } ] } }, { &quot;join_explain&quot;: { &quot;select#&quot;: 1, &quot;steps&quot;: [ ] } } ] } 1 row in set (0.02 sec) 内容是非常长的 JSON 格式，所以推荐把结果转存到其他地方，然后用 JSON 的转换工具来辅助查看，如果要看索引的选择情况，就重点关注这个 JSON 的ref_optimizer_key_uses，rows_estimation 及之后的部分，这里会展示索引选择相关的信息，截取一部分结果作为示例： { &quot;ref_optimizer_key_uses&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;field&quot;: &quot;age&quot;, &quot;equals&quot;: &quot;21&quot;, &quot;null_rejecting&quot;: true } ] } ...... &quot;chosen_range_access_summary&quot;: { &quot;range_access_plan&quot;: { &quot;type&quot;: &quot;range_scan&quot;, &quot;index&quot;: &quot;idx_age&quot;, &quot;rows&quot;: 1, &quot;ranges&quot;: [ &quot;21 &lt;= age &lt;= 21&quot; ] }, &quot;rows_for_plan&quot;: 1, &quot;cost_for_plan&quot;: 0.61, &quot;chosen&quot;: true } 3、引擎参数配置分析 上面的篇幅中，我们针对SQL层面进行了可能导致慢查询的原因分析，MySQL的数据最终都会存储在磁盘上，因此操作系统的I/O情况也会影响MySQL的运行性能，这一章节我们将从底层入手，从操作系统I/O层面分析MySQL执行性能问题。 I/O性能分析 Linux系统查看系统I/O情况，可以使用iostat命令： [root@VM-16-14-centos ~]# iostat -x 1 -m Linux 3.10.0-1160.11.1.el7.x86_64 (VM-16-14-centos) 12/21/2022 _x86_64_ (1 CPU) avg-cpu: %user %nice %system %iowait %steal %idle 0.82 0.00 0.67 0.07 0.00 98.44 Device: rrqm/s wrqm/s r/s w/s rMB/s wMB/s avgrq-sz avgqu-sz await r_await w_await svctm %util vda 0.00 1.67 0.04 2.49 0.00 0.02 17.55 0.01 2.34 3.74 2.31 0.29 0.07 scd0 0.00 0.00 0.00 0.00 0.00 0.00 7.10 0.00 0.89 0.89 0.00 0.88 0.00 avg-cpu 自然就是 CPU 相关的指标，判断 IO 问题时可以关注 %iowait，其他指标的意义如下： r/s 和 w/s：合并过后的读请求和写请求的每秒请求数，可以当做 IOPS 来理解。 rMB/s 和 wMB/s：磁盘的读写吞吐量。 rrqm/s 和 wrqm/s：每秒合并的读请求和写请求数量。 r_await 和 w_await：读请求和写请求的平均响应时间，包含真正的处理时间和队列中的等待时间（ms）。 avgrq-sz：平均每次设备I/O操作的数据大小 (扇区)。 avgqu-sz：平均I/O队列长度。 await：平均每次设备I/O操作的等待时间 (毫秒)。 scvtm：计算出来的平均 IO 响应时间，目前已经不准确，不用再关注。 %util：如果使用了 RAID 或者 SSD，则忽略这个指标，仅在单块机械盘上准确。 一般来说，评价一块 IO 设备（忽略机械盘的情况，没有评价的意义）是否达到了高负载情况，可以看这几个指标：r/s，w/s，rMB/s，wMB/s，r_await，w_await，avgqu-sz。 MySQL I/O参数 MySQL 涉及到 IO 相关的参数会比较多，因此这里仅一部分经常用到的参数： 参数 默认设置 备注 innodb_io_capacity 200 定义了后台任务可用的 IOPS 量，InnoDB后台任务可用的每秒I/O操作数（IOPS），例如从缓冲池冲刷页面和从变更缓冲区合并数据。 innodb_io_capacity_max 动态 定义了后台任务可用的最大 IOPS 量 innodb_flush_log_at_trx_commit 1 控制事务的提交策略 0：日志缓存区将每隔一秒写到日志文件中，并且将日志文件的数据刷新到磁盘上。该模式下在事务提交时不会主动触发写入磁盘的操作。 1：每次事务提交时RDS for MySQL都会把日志缓存区的数据写入日志文件中，并且刷新到磁盘中，该模式为系统默认。 2：每次事务提交时RDS for MySQL都会把日志缓存区的数据写入日志文件中，但是并不会同时刷新到磁盘上。该模式下，MySQL会每秒执行一次刷新磁盘操作。 sync_binlog 1 控制 binlog 落盘的频率0 ：存储引擎不进行binlog的刷新到磁盘，而由操作系统的文件系统控制缓存刷新。1：每提交一次事务，存储引擎调用文件系统的sync操作进行一次缓存的刷新，这种方式最安全，但性能较低。n：在每N次binlog日志文件写入后与磁盘同步，存储引擎调用文件系统的sync操作进行一次缓存的刷新。 innodb_io_capacity 和 innodb_io_capacity_max 是最直接限制 IOPS 的指标，大多数时候，SSD 可以设置成 16000 或者更高的数值，如果是云主机或者其他的共享存储设备，则需要了解一下详细的 IOPS 上限再具体调整。 trx_commit 和 sync_binlog 这两个参数也放进来的原因是不同的参数组合对 IO 的压力也会有区别。 通常的用法是双 1 或者 20（二零），参考官方文档的描述，双 1 在每次提交事务的时候都会刷盘，对 IO 的压力要高不少； 20 则是滞后刷盘，对 IO 的压力会较小，因此写入 QPS 会高一些。 另外，可以关注到一个细节，innodb_io_capacity 的描述对象是：后台任务。这代表着 MySQL 后台的 flush，purge 操作会受到这个参数设置的限制。 吞吐量和 IOPS ，一般情况下衡量 IO 系统性能最直观的指标，并没有特别的提及，主要原因还是判断起来很简单：如果iostat的指标已经达到或者接近了实际硬件的指标（比如达到了 75%），那么根据业务量增长的情况及早规划硬件升级或者其他的手段来分散读写压力。 常规的手段，可以简单的遵循以下场景来酌情使用：读多写少读写分离，写多读少拆库拆表加缓存。 其他原因分析 网络抖动 目前的互联网应用服务，数据库的部署与应用服务的部署，不会在一台服务器上，那么应用服务器与数据库服务器之间就需要通过网络通信，一般情况来讲，都会在同机房或同一个可用区进行部署，以保证网络通信的质量。 但是难免可能会出现网络抖动的情况，这种情况下，对应用服务来讲，可能会出现一条SQL执行较慢的情况，但不是由于数据库原因导致的，而是由于网络原因导致的。 发现偶现的SQL执行慢，且SQL本身执行计划没有问题，可以从网络的角度分析问题，在服务所在的机器ping数据库服务器，查看响应时间，特别针对数据库服务器与业务服务器跨城市的情况，如果没有拉通专线访问，会很容易出现网络慢导致的问题。 单表数据量过大 上面我们提到了InnoDB的数据存储方式是面向主键索引进行数据存储的。 InnoDB的数据表数量级超过几千万后，性能会出现下降，核心是由于B+Tree的数据结构导致的。 因此，当你的数据表超过几千万量级的时候，SQL执行即使全部命中的索引，也有可能出现执行慢的情况。 这个时候，建议考虑采用拆表。目前开源的优秀的分库分表中间件有很多，例如sharing-JDBC、MyCat等，可以根据业务的实际情况进行选择，这里就不过多的进行赘述。 总结 本篇，我们围绕着一个问题：一条SQL执行较慢可能有哪些原因导致的？ 进行了研究，总结一下，大部分的慢查询其实均由SQL书写不当导致的，通过explain命令结合实际业务场景分析，可以解决绝大多数的慢查询问题，对于一些疑难杂症SQL，使用MySQL强大的SQL分析工具，也可以找出真正的问题原因。 另外，系统层面的分析也是必不可少的，作为开发人员，我们也需要掌握一些DBA的分析手段，检查MySQL运行性能情况，保证数据库服务的稳定运行。 本篇参考： MySQL官方文档The Slow Query Log： https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_long_query_time https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information mysql or/in性能对比： https://www.cnblogs.com/chihirotan/p/7457204.html MySQL explain结果Extra中”Using Index”与”Using where; Using index”区别探究： https://www.cnblogs.com/AcAc-t/p/mysql_explain_difference_between_using_index_and_using_where.html MySQL General Thread States： https://dev.mysql.com/doc/refman/8.0/en/general-thread-states.html innodb_flush_log_at_trx_commit和sync_binlog参数详解： https://support.huaweicloud.com/bestpractice-rds/rds_02_0010.html">
<link rel="canonical" href="http://localhost:4000/mysql/2024/09/25/MySQL%E6%85%A2SQL%E6%8E%A2%E7%A9%B6.html">
<meta property="og:url" content="http://localhost:4000/mysql/2024/09/25/MySQL%E6%85%A2SQL%E6%8E%A2%E7%A9%B6.html">
<meta property="og:site_name" content="wtopps">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-09-25T00:00:00+08:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="MySQL慢SQL探究">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"GitHub User"},"dateModified":"2024-09-25T00:00:00+08:00","datePublished":"2024-09-25T00:00:00+08:00","description":"前言 我们在日常开发中，一定遇见过某些SQL执行较慢的情况，我们俗称“慢SQL”，如果你对系统的接口性能要求较高的话，一定不会放过这种SQL，肯定会想办法进行解决，那么，导致慢SQL出现的原因，究竟可能都有哪些呢？ 这是一道经典的面试题，就此我们来研究一番，下面，我们就来好好看一下，原因可能出在哪里。 本篇我们将从如下几个方面进行讨论： 1、慢SQL捕获 2、执行计划分析 3、引擎参数配置分析 让我们就此开启本次慢SQL分析之旅，Let’s go！ ps: 本篇文章的讨论，主要基于MySQL8.0数据库，Oracle等其他数据库不在本篇讨论范围之列。 1、慢SQL捕获 追查应用服务的慢SQL，首先需要追踪哪些SQL可能是慢SQL，对于Java服务，很多数据库中间件提供了慢SQL的追踪能力，例如Alibaba Druid，会将服务运行过程中的慢SQL打印到日志文件，方便开发运维人员追查。 MySQL当然也提供了捕获慢查询的监控能力，记录在MySQL中执行时间超过指定时间的SQL语句。 默认情况下，MySQL 并没有开启慢日志，可以通过修改 slow_query_log 参数来打开慢日志。与慢日志相关的参数介绍如下： slow_query_log：是否启用慢查询日志，1表示开启，0表示关闭，默认为关闭。 slow_query_log_file：指定慢查询日志位置及名称，默认值为host_name-slow.log，可指定绝对路径。 long_query_time：慢查询执行时间阈值，超过此时间会记录，默认为10，取值范围0~31536000，单位为秒。 min_examined_row_limit：对于查询扫描行数小于此参数的SQL，将不会记录到慢查询日志中，默认为0，最大值(bit-64)为18446744073709551615。 log_output：慢查询日志输出目标，默认为FILE，即输出到文件，取值为TABLE、FILE、NONE。 log_timestamps：主要是控制 error log、slow log、genera log 日志文件中的显示时区，默认使用UTC时区，取值为UTC、SYSTEM，建议改为 SYSTEM 系统时区。 log_queries_not_using_indexes：是否记录所有未使用索引的查询语句，默认为OFF。 log_slow_admin_statements：慢速管理语句是否写入慢日志中，管理语句包含 ALTER TABLE, ANALYZE TABLE, CHECK TABLE, CREATE INDEX, DROP INDEX, OPTIMIZE TABLE, REPAIR TABLE，默认为 OFF 即不写入。 一般情况下，我们只需开启慢日志记录，配置下阈值时间，其余参数可按默认配置。对于阈值时间，可灵活调整，比如说可以设置为 1s 或 3s 。 慢查询追踪配置方式 MySQL提供了两种配置慢查询参数的方式，提供给开发者使用，下面我们依次来看一下。 第一种，将慢查询参数配置写入 MySQL 配置文件，永久生效 # 慢查询日志相关配置，可根据实际情况修改 vim /etc/my.cnf [mysqld] slow_query_log = 1 slow_query_log_file = /var/log/mysql/sql-slow.log long_query_time = 1 log_timestamps = SYSTEM log_output = FILE 第二种，MySQL Server 中临时开启慢查询功能，当 MySQL Server 重启时，配置修改则全部失效并恢复原状 SET GLOBAL slow_query_log = &#39;ON&#39;; SET GLOBAL slow_query_log_file = &#39;/var/log/mysql/sql-slow.log&#39;; SET GLOBAL log_queries_not_using_indexes = &#39;ON&#39;; SET SESSION long_query_time = 1; SET SESSION min_examined_row_limit = 100; 下面我们具体看下，慢日志会记录哪些内容？我们执行一条较慢的查询 SQL ，来看下在慢日志中的体现。 # Time: 2022-11-02T09:23:37.004885Z # User@Host: wtopps[wtopps] @ localhost [] Id: 10831 # Query_time: 1.609214 Lock_time: 0.003828 Rows_sent: 2050008 Rows_examined: 2150010 SET timestamp=1667381015; SELECT A.* FROM `user` A LEFT JOIN grade B ON A.`id` = B.`user_id`; 对于每一组慢SQL，日志内容格式如下： 第一行记录的是该条 SQL 执行的时刻（如果 log_timestamps 参数为 UTC ，则改时间会显示 UTC 时区时间） 第二行记录的是执行该语句的用户和 IP 以及链接 id 第三行的几个字段含义如下： Query_time：语句执行时间，以秒为单位。 Lock_time：获取锁的时间(以秒为单位)。 Rows_sent：发送给 Client 端的行数。 Rows_examined：服务器层检查的行数(不计算存储引擎内部的任何处理) 通过慢查询日志，我们可以捕获到具体的慢SQL，接下来，则要具体分析慢SQL产生的可能原因。 2、情况分析 为什么查询会慢？ 在尝试编写快速的查询之前，需要清楚一点，真正重要是响应时间。如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。 MySQL在执行查询的时候有哪些子任务，哪些子任务运行的速度很慢？这里很难给出完整的列表，通常来说，查询的生命周期大致可以按照顺序来看： 从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。 在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。 根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。 在每一个消耗大量时间的查询案例中，大概率会出现一些不必要的额外操作、某些操作被额外地重复了很多次、某些操作执行得太慢等。优化查询的目的就是减少和消除这些操作所花费的时间。 再次申明一点，对于一个查询的全部生命周期，上面列的并不完整。这里我们只是想说明：了解查询的生命周期、清楚查询的时间消耗情况对于优化查询有很大的意义。有了这些概念，我们再一起来看看如何优化查询。 捕获具体的慢查询SQL后，我们需要对可能导致慢查询的原因进行分析，我们可以从如下几个角度，对问题进行拆解： SQL执行计划分析 引擎参数配置分析 引擎参数配置分析（网络，物理机配置，内存，机器负载I/O） 2.1 SQL执行计划分析 查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免地需要筛选大量数据，但在实际业务场景中，这并不常见。 大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效： 1．确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。 2．确认MySQL服务器层是否在分析大量超过需要的数据行。 有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU 和内存资源。 因此，合理的使用索引的重要性就凸显出来，如果查询中的查询条件未命中索引字段，MySQL引擎则只能对全量的数据进行检索，再根据查询条件进行过滤，筛选出目标的数据集，这个过程是非常耗时且低效的。 接下来，我们将逐步对SQL执行的过程进行分析拆解，通过工具手段剖析慢查询的具体原因。 explain执行计划分析 对于SQL执行过程分析，最先登场的毫无疑问就是 explain语句了， explain是我们在日常开发最常使用的分析命令。其使用方式，这里不再赘述，一般来说，95% 的慢查询问题只需要 explain 就可以解决了。 对于explain执行计划的分析，我们需要关注最简单的衡量查询开销的两个点： 扫描的行数 返回的行数 通过explain执行计划可以获得SQL在执行时预估的扫描行数以及返回行数的大概比例，这在一定程度上能够说明该查询找到需要的数据的效率高不高。 但这个指标也并不是绝对的，因为并不是所有的行的访问代价都是相同的。较短的行的访问速度更快，内存中的行也比磁盘中的行的访问速度要，快得多。 理想情况下扫描的行数和返回的行数应该是相同的。但实际情况中这种情况并不多见。 例如在做一个多表的join关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1：1和10：1之间，不过有时候这个值也可能非常非常大。 比值越大则意味着查询效率越低，因为引擎执行扫描出的大部分数据行都会被丢弃，这也意味着需要执行更多的I/O操作，因此尽可能降低扫描的行数对返回的行数的比率，是我们对慢查询优化的关键所在。 一般MySQL 能够使用如下三种方式应用where条件，从好到坏依次为： 在索引中使用where条件来过滤不匹配的记录。这是在存储引擎层完成的。 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。 Extra中Using Index与Using Where，MySQL官方文档的解释如下： Using Index The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. This strategy can be used when the query uses only columns that are part of a single index. Using Where A WHERE clause is used to restrict which rows to match against the next table or send to the client. Unless you specifically intend to fetch or examine all rows from the table, you may have something wrong in your query if the Extra value is not Using where and the table join type is ALL or index. 使用explain判断导致查询慢的原因，判断依据可以根据如下几点： where查询条件中的字段，是否是索引字段，索引字段是否满足了最左匹配原则 where查询条件中是否对索引字段使用了函数处理 对索引字段使用函数操作，会使得索引失效 where查询条件中是否存在like %字段% 情况 like %%的全模糊匹配，会使得索引失效，如需使用like，请使用like 字段% 对于select *的查询，该表的字段数量为多少 对于巨型宽表，例如上百个字段的大表，select * 是效率低下的选择，实际业务中很少有情况会需要全部字段的情况，根据需要查询特定的字段是非常必要的 where查询条件中是否使用or，如果使用了，or的字段是否是主键或者索引字段 对于主键或索引字段，or与in不存在性能差距，对于非索引字段，or的性能会低于in In many database servers, IN() is just a synonym for multiple OR clauses, because the two are logically equivalent. Not so in MySQL, which sorts the values in the IN() list and uses a fast binary search to see whether a value is in the list. This is O(Log n) in the size of the list, whereas an equivalent series of OR clauses is O(n) in the size of the list (i.e., much slower for large lists) 查询是否使用了多个表(大于3张) 的join操作，join表的数据量级如何，是否使用了索引字段进行查询 对于多表join的复杂联合查询，是可能产生慢SQL的重灾区，join子表的顺序决定了扫描结果集会有多大，需要结合explain进行分析判断 实际业务场景中，也尽可能的避免多表join操作，需要在表设计阶段就做好冗余字段的考虑 where查询条件是否使用了分页查询，分页深度是多大 limit 10, offset 100000，MySQL在实际执行时，会查询出100010条记录，然后丢弃前100000条，性能会极为的糟糕 对于深分页查询优化，当执行深度分页时，可以带入主键ID作为查询条件，执行下一页的查询时，将上一页最大的主键ID作为条件，id &gt; last_page_max_id 综上我们总结，SQL执行时其扫描的行数决定了执行的效率，而决定扫描行数的关键，则是索引的命中情况与索引的质量。 Tips:关于索引的一些小建议 1、唯一索引命名uk字段，普通索引命名idx字段，过长时可用首字母替代 2、尽量避免三张表以上的join，对于多表join的情况，可以视情况考虑将一个大查询拆分成多个子查询，对结果集在业务层进行聚合处理。如必须要多表join的场景，特别注意多连表查询的扫描行数问题以及索引的命中情况。 3、varchar长字段建立索引，需要指定索引长度，根据文本区分度来决定长度。 4、避免左模糊，全模糊匹配。 5、order by 字段放在索引最后列，避免filesort 6、考虑利用覆盖索引来进行查询操作，避免回表 7、性能优化目标，需要为range级别以上，最好是ref级别，或者const最好。 8、区分度高的列在索引最左边。 9、避免字段类型不同造成的隐式转换，导致索引失效。例如：varchar和数字类型 10、根据大多数SQL来创建索引。 11、对于运行较久的大表，需要关注索引字段的区分度问题，当索引值出现了严重倾斜时，需要考虑优化拆分索引值。 PROFILE分析 通过使用explain分析SQL的执行计划，我们可以看到SQL执行过程中是否使用索引，使用了哪些索引，索引扫描的行数等，但MySQL的慢查询，并不一定慢在有没有索引，SQL的执行环节中任意一环出了问题都会表现为查询变慢，所以即使执行过程命中了索引，explain的结果也很完美，但是还是慢，怎么办？ 这时候，就需要profile工具来帮忙了，这个命令可以详细的列出 SQL 语句在每一个步骤消耗的时间，前提（缺点）是先执行一遍语句。 PROFILE 默认是关闭的，所以需要在client端先打开，操作如下： set session profiling = 1; 在实际的生产环境中，可能会需要加大profile的队列，保证想要查看的 profile结果还保存着，因此可以用如下操作来增加profile的队列大小： set session profiling_history_size = 50; 让我们一起来看一下profile分析如何使用，我们先执行下面的SQL： mysql&gt; explain select * from user where name = &#39;小六&#39; and code = 300000003; +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ | 1 | SIMPLE | user | NULL | ALL | NULL | NULL | NULL | NULL | 2043040 | 1.00 | Using where | +----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) 这个一个典型的效果较差的查询，type=ALL，没有命中索引，执行了全表扫描，我们使用profile分析一下各阶段的执行时间： mysql&gt; show profiles; +----------+------------+---------------------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+---------------------------------------------------------------+ | 1 | 0.55695825 | select * from user where name = &#39;小六&#39; and code = 300000003 | +----------+------------+---------------------------------------------------------------+ 1 row in set, 1 warning (0.00 sec) 找到我们需要分析的语句，查询执行耗时详情： mysql&gt; show profile block io,cpu,memory,source for query 1; 从profile执行结果中，我们可以清晰的看到一条SQL在每个执行阶段的耗时、CPU使用率、IO等指标，帮助我们定位到慢查询具体执行耗时的阶段，对于该条SQL，执行过程中最耗时的部分是executing部分，executing阶段包括了执行线程正在为SELECT读取和处理数据行，并将数据发送到客户端。因为在这个状态下发生的操作往往执行大量的磁盘读取，所以它往往是在整个查询的生命周期中运行时间最长的一个阶段。 经过了对SQL语句进行explain与profile分析之后，一个 SQL 为什么慢，慢在哪里基本上可以定位出来了，那么最后的手段主要是解决什么问题呢？ 我们将使用最终的分析工具，OPTIMIZER_TRACE。 OPTIMIZER_TRACE分析 OPTIMIZER_TRACE 是 MySQL 5.6 添加的新功能，这个功能可以看到内部查询计划的 TRACE 信息，也就是MySQL在执行过程中的具体决策细节，从而可以知道 MySQL 是如何在众多索引中的挑选最合适的索引。 如果我们通过执行计划，发现MySQL选择的索引并不符合我们的预期，就需要根据 OPTIMIZER_TRACE 的信息来判断为什么会选择它，是 MySQL 的配置原因，还是 SQL 某些地方写的不好导致 MySQL 误判。 开启这个功能的方式如下： set session optimizer_trace=&#39;enabled=on&#39;; 在客户端执行一个EXPLAIN语句，生成一个执行计划，然后在information_chema.optimizer_trace的表里面查找这一条语句对应的信息： mysql&gt; select * from information_schema.optimizer_trace; | explain select * from user where age = 21 | { &quot;steps&quot;: [ { &quot;join_preparation&quot;: { &quot;select#&quot;: 1, &quot;steps&quot;: [ { &quot;expanded_query&quot;: &quot;/* select#1 */ select `user`.`id` AS `id`,`user`.`name` AS `name`,`user`.`age` AS `age`,`user`.`code` AS `code` from `user` where (`user`.`age` = 21)&quot; } ] } }, { &quot;join_optimization&quot;: { &quot;select#&quot;: 1, &quot;steps&quot;: [ { &quot;condition_processing&quot;: { &quot;condition&quot;: &quot;WHERE&quot;, &quot;original_condition&quot;: &quot;(`user`.`age` = 21)&quot;, &quot;steps&quot;: [ { &quot;transformation&quot;: &quot;equality_propagation&quot;, &quot;resulting_condition&quot;: &quot;multiple equal(21, `user`.`age`)&quot; }, { &quot;transformation&quot;: &quot;constant_propagation&quot;, &quot;resulting_condition&quot;: &quot;multiple equal(21, `user`.`age`)&quot; }, { &quot;transformation&quot;: &quot;trivial_condition_removal&quot;, &quot;resulting_condition&quot;: &quot;multiple equal(21, `user`.`age`)&quot; } ] } }, { &quot;substitute_generated_columns&quot;: { } }, { &quot;table_dependencies&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;row_may_be_null&quot;: false, &quot;map_bit&quot;: 0, &quot;depends_on_map_bits&quot;: [ ] } ] }, { &quot;ref_optimizer_key_uses&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;field&quot;: &quot;age&quot;, &quot;equals&quot;: &quot;21&quot;, &quot;null_rejecting&quot;: true } ] }, { &quot;rows_estimation&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;range_analysis&quot;: { &quot;table_scan&quot;: { &quot;rows&quot;: 2043040, &quot;cost&quot;: 205676 }, &quot;potential_range_indexes&quot;: [ { &quot;index&quot;: &quot;PRIMARY&quot;, &quot;usable&quot;: false, &quot;cause&quot;: &quot;not_applicable&quot; }, { &quot;index&quot;: &quot;idx_age&quot;, &quot;usable&quot;: true, &quot;key_parts&quot;: [ &quot;age&quot;, &quot;id&quot; ] } ], &quot;setup_range_conditions&quot;: [ ], &quot;group_index_range&quot;: { &quot;chosen&quot;: false, &quot;cause&quot;: &quot;not_group_by_or_distinct&quot; }, &quot;skip_scan_range&quot;: { &quot;potential_skip_scan_indexes&quot;: [ { &quot;index&quot;: &quot;idx_age&quot;, &quot;usable&quot;: false, &quot;cause&quot;: &quot;query_references_nonkey_column&quot; } ] }, &quot;analyzing_range_alternatives&quot;: { &quot;range_scan_alternatives&quot;: [ { &quot;index&quot;: &quot;idx_age&quot;, &quot;ranges&quot;: [ &quot;21 &lt;= age &lt;= 21&quot; ], &quot;index_dives_for_eq_ranges&quot;: true, &quot;rowid_ordered&quot;: true, &quot;using_mrr&quot;: false, &quot;index_only&quot;: false, &quot;in_memory&quot;: 0.788627, &quot;rows&quot;: 1, &quot;cost&quot;: 0.61, &quot;chosen&quot;: true } ], &quot;analyzing_roworder_intersect&quot;: { &quot;usable&quot;: false, &quot;cause&quot;: &quot;too_few_roworder_scans&quot; } }, &quot;chosen_range_access_summary&quot;: { &quot;range_access_plan&quot;: { &quot;type&quot;: &quot;range_scan&quot;, &quot;index&quot;: &quot;idx_age&quot;, &quot;rows&quot;: 1, &quot;ranges&quot;: [ &quot;21 &lt;= age &lt;= 21&quot; ] }, &quot;rows_for_plan&quot;: 1, &quot;cost_for_plan&quot;: 0.61, &quot;chosen&quot;: true } } } ] }, { &quot;considered_execution_plans&quot;: [ { &quot;plan_prefix&quot;: [ ], &quot;table&quot;: &quot;`user`&quot;, &quot;best_access_path&quot;: { &quot;considered_access_paths&quot;: [ { &quot;access_type&quot;: &quot;ref&quot;, &quot;index&quot;: &quot;idx_age&quot;, &quot;rows&quot;: 1, &quot;cost&quot;: 0.35, &quot;chosen&quot;: true }, { &quot;access_type&quot;: &quot;range&quot;, &quot;range_details&quot;: { &quot;used_index&quot;: &quot;idx_age&quot; }, &quot;chosen&quot;: false, &quot;cause&quot;: &quot;heuristic_index_cheaper&quot; } ] }, &quot;condition_filtering_pct&quot;: 100, &quot;rows_for_plan&quot;: 1, &quot;cost_for_plan&quot;: 0.35, &quot;chosen&quot;: true } ] }, { &quot;attaching_conditions_to_tables&quot;: { &quot;original_condition&quot;: &quot;(`user`.`age` = 21)&quot;, &quot;attached_conditions_computation&quot;: [ ], &quot;attached_conditions_summary&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;attached&quot;: &quot;(`user`.`age` = 21)&quot; } ] } }, { &quot;finalizing_table_conditions&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;original_table_condition&quot;: &quot;(`user`.`age` = 21)&quot;, &quot;final_table_condition &quot;: null } ] }, { &quot;refine_plan&quot;: [ { &quot;table&quot;: &quot;`user`&quot; } ] } ] } }, { &quot;join_explain&quot;: { &quot;select#&quot;: 1, &quot;steps&quot;: [ ] } } ] } 1 row in set (0.02 sec) 内容是非常长的 JSON 格式，所以推荐把结果转存到其他地方，然后用 JSON 的转换工具来辅助查看，如果要看索引的选择情况，就重点关注这个 JSON 的ref_optimizer_key_uses，rows_estimation 及之后的部分，这里会展示索引选择相关的信息，截取一部分结果作为示例： { &quot;ref_optimizer_key_uses&quot;: [ { &quot;table&quot;: &quot;`user`&quot;, &quot;field&quot;: &quot;age&quot;, &quot;equals&quot;: &quot;21&quot;, &quot;null_rejecting&quot;: true } ] } ...... &quot;chosen_range_access_summary&quot;: { &quot;range_access_plan&quot;: { &quot;type&quot;: &quot;range_scan&quot;, &quot;index&quot;: &quot;idx_age&quot;, &quot;rows&quot;: 1, &quot;ranges&quot;: [ &quot;21 &lt;= age &lt;= 21&quot; ] }, &quot;rows_for_plan&quot;: 1, &quot;cost_for_plan&quot;: 0.61, &quot;chosen&quot;: true } 3、引擎参数配置分析 上面的篇幅中，我们针对SQL层面进行了可能导致慢查询的原因分析，MySQL的数据最终都会存储在磁盘上，因此操作系统的I/O情况也会影响MySQL的运行性能，这一章节我们将从底层入手，从操作系统I/O层面分析MySQL执行性能问题。 I/O性能分析 Linux系统查看系统I/O情况，可以使用iostat命令： [root@VM-16-14-centos ~]# iostat -x 1 -m Linux 3.10.0-1160.11.1.el7.x86_64 (VM-16-14-centos) 12/21/2022 _x86_64_ (1 CPU) avg-cpu: %user %nice %system %iowait %steal %idle 0.82 0.00 0.67 0.07 0.00 98.44 Device: rrqm/s wrqm/s r/s w/s rMB/s wMB/s avgrq-sz avgqu-sz await r_await w_await svctm %util vda 0.00 1.67 0.04 2.49 0.00 0.02 17.55 0.01 2.34 3.74 2.31 0.29 0.07 scd0 0.00 0.00 0.00 0.00 0.00 0.00 7.10 0.00 0.89 0.89 0.00 0.88 0.00 avg-cpu 自然就是 CPU 相关的指标，判断 IO 问题时可以关注 %iowait，其他指标的意义如下： r/s 和 w/s：合并过后的读请求和写请求的每秒请求数，可以当做 IOPS 来理解。 rMB/s 和 wMB/s：磁盘的读写吞吐量。 rrqm/s 和 wrqm/s：每秒合并的读请求和写请求数量。 r_await 和 w_await：读请求和写请求的平均响应时间，包含真正的处理时间和队列中的等待时间（ms）。 avgrq-sz：平均每次设备I/O操作的数据大小 (扇区)。 avgqu-sz：平均I/O队列长度。 await：平均每次设备I/O操作的等待时间 (毫秒)。 scvtm：计算出来的平均 IO 响应时间，目前已经不准确，不用再关注。 %util：如果使用了 RAID 或者 SSD，则忽略这个指标，仅在单块机械盘上准确。 一般来说，评价一块 IO 设备（忽略机械盘的情况，没有评价的意义）是否达到了高负载情况，可以看这几个指标：r/s，w/s，rMB/s，wMB/s，r_await，w_await，avgqu-sz。 MySQL I/O参数 MySQL 涉及到 IO 相关的参数会比较多，因此这里仅一部分经常用到的参数： 参数 默认设置 备注 innodb_io_capacity 200 定义了后台任务可用的 IOPS 量，InnoDB后台任务可用的每秒I/O操作数（IOPS），例如从缓冲池冲刷页面和从变更缓冲区合并数据。 innodb_io_capacity_max 动态 定义了后台任务可用的最大 IOPS 量 innodb_flush_log_at_trx_commit 1 控制事务的提交策略 0：日志缓存区将每隔一秒写到日志文件中，并且将日志文件的数据刷新到磁盘上。该模式下在事务提交时不会主动触发写入磁盘的操作。 1：每次事务提交时RDS for MySQL都会把日志缓存区的数据写入日志文件中，并且刷新到磁盘中，该模式为系统默认。 2：每次事务提交时RDS for MySQL都会把日志缓存区的数据写入日志文件中，但是并不会同时刷新到磁盘上。该模式下，MySQL会每秒执行一次刷新磁盘操作。 sync_binlog 1 控制 binlog 落盘的频率0 ：存储引擎不进行binlog的刷新到磁盘，而由操作系统的文件系统控制缓存刷新。1：每提交一次事务，存储引擎调用文件系统的sync操作进行一次缓存的刷新，这种方式最安全，但性能较低。n：在每N次binlog日志文件写入后与磁盘同步，存储引擎调用文件系统的sync操作进行一次缓存的刷新。 innodb_io_capacity 和 innodb_io_capacity_max 是最直接限制 IOPS 的指标，大多数时候，SSD 可以设置成 16000 或者更高的数值，如果是云主机或者其他的共享存储设备，则需要了解一下详细的 IOPS 上限再具体调整。 trx_commit 和 sync_binlog 这两个参数也放进来的原因是不同的参数组合对 IO 的压力也会有区别。 通常的用法是双 1 或者 20（二零），参考官方文档的描述，双 1 在每次提交事务的时候都会刷盘，对 IO 的压力要高不少； 20 则是滞后刷盘，对 IO 的压力会较小，因此写入 QPS 会高一些。 另外，可以关注到一个细节，innodb_io_capacity 的描述对象是：后台任务。这代表着 MySQL 后台的 flush，purge 操作会受到这个参数设置的限制。 吞吐量和 IOPS ，一般情况下衡量 IO 系统性能最直观的指标，并没有特别的提及，主要原因还是判断起来很简单：如果iostat的指标已经达到或者接近了实际硬件的指标（比如达到了 75%），那么根据业务量增长的情况及早规划硬件升级或者其他的手段来分散读写压力。 常规的手段，可以简单的遵循以下场景来酌情使用：读多写少读写分离，写多读少拆库拆表加缓存。 其他原因分析 网络抖动 目前的互联网应用服务，数据库的部署与应用服务的部署，不会在一台服务器上，那么应用服务器与数据库服务器之间就需要通过网络通信，一般情况来讲，都会在同机房或同一个可用区进行部署，以保证网络通信的质量。 但是难免可能会出现网络抖动的情况，这种情况下，对应用服务来讲，可能会出现一条SQL执行较慢的情况，但不是由于数据库原因导致的，而是由于网络原因导致的。 发现偶现的SQL执行慢，且SQL本身执行计划没有问题，可以从网络的角度分析问题，在服务所在的机器ping数据库服务器，查看响应时间，特别针对数据库服务器与业务服务器跨城市的情况，如果没有拉通专线访问，会很容易出现网络慢导致的问题。 单表数据量过大 上面我们提到了InnoDB的数据存储方式是面向主键索引进行数据存储的。 InnoDB的数据表数量级超过几千万后，性能会出现下降，核心是由于B+Tree的数据结构导致的。 因此，当你的数据表超过几千万量级的时候，SQL执行即使全部命中的索引，也有可能出现执行慢的情况。 这个时候，建议考虑采用拆表。目前开源的优秀的分库分表中间件有很多，例如sharing-JDBC、MyCat等，可以根据业务的实际情况进行选择，这里就不过多的进行赘述。 总结 本篇，我们围绕着一个问题：一条SQL执行较慢可能有哪些原因导致的？ 进行了研究，总结一下，大部分的慢查询其实均由SQL书写不当导致的，通过explain命令结合实际业务场景分析，可以解决绝大多数的慢查询问题，对于一些疑难杂症SQL，使用MySQL强大的SQL分析工具，也可以找出真正的问题原因。 另外，系统层面的分析也是必不可少的，作为开发人员，我们也需要掌握一些DBA的分析手段，检查MySQL运行性能情况，保证数据库服务的稳定运行。 本篇参考： MySQL官方文档The Slow Query Log： https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_long_query_time https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information mysql or/in性能对比： https://www.cnblogs.com/chihirotan/p/7457204.html MySQL explain结果Extra中”Using Index”与”Using where; Using index”区别探究： https://www.cnblogs.com/AcAc-t/p/mysql_explain_difference_between_using_index_and_using_where.html MySQL General Thread States： https://dev.mysql.com/doc/refman/8.0/en/general-thread-states.html innodb_flush_log_at_trx_commit和sync_binlog参数详解： https://support.huaweicloud.com/bestpractice-rds/rds_02_0010.html","headline":"MySQL慢SQL探究","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/mysql/2024/09/25/MySQL%E6%85%A2SQL%E6%8E%A2%E7%A9%B6.html"},"url":"http://localhost:4000/mysql/2024/09/25/MySQL%E6%85%A2SQL%E6%8E%A2%E7%A9%B6.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="canonical" href="http://localhost:4000">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="wtopps">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js" async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe-lightbox.umd.min.js" async></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe.umd.min.js" async></script>
<link href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/photoswipe.min.css" rel="stylesheet">
<style>
  .pswp .pswp__container .pswp__img {
    background-color: white;
  }
</style>

<script>
  function initPhotoSwipe() {
    let customOptions = {};

    try {
      const data = ``.replaceAll("=>", ":");
      customOptions = JSON.parse(data);
    } catch (e) {
      console.info("Invalid custom photo previewer options! " + e.message);
    }

    // Define object and gallery options
    const options = Object.assign(
      {
        gallery: "section.main",
        children: "a.photo-swipe",
        photo_scale: 2,
        // dynamic import is not supported in UMD version
        pswpModule: PhotoSwipe,
      },
      customOptions
    );

    const galleryEl = document.querySelector(options.gallery);
    if (!galleryEl) {
      return;
    }

    const imgEls = [];
    const els = galleryEl.querySelectorAll("img:not(.emoji)");
    els.forEach((el) => {
      if (el.src.trim() == "") {
        return;
      }
      if (!imgEls.includes(el)) {
        imgEls.push(el);
      }
    });

    if (imgEls.length === 0) {
      return;
    }

    imgEls.forEach((imgEl) => {
      imgEl.outerHTML = `
      <a class="photo-swipe"
        href="${imgEl.src}"
        data-pswp-width="${
          Math.max(imgEl.naturalWidth, imgEl.width) * options.photo_scale
        }"
        data-pswp-height="${
          Math.max(imgEl.naturalHeight, imgEl.height) * options.photo_scale
        }"
        data-pswp-caption="${imgEl.getAttribute("caption") || imgEl.alt}"
        target="_blank">
        ${imgEl.outerHTML}
      </a>`;
    });

    // Initialize PhotoSwipe 5
    var lightbox = new PhotoSwipeLightbox(options);

    lightbox.init();
  }

  window.addEventListener("load", initPhotoSwipe);
</script>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="wtopps" src="" onerror="this.style.display='none'">
  wtopps
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/">HOME</a><a class="page-link" href="/tags.html">TAGS</a>









<div class="page-link" style="display: inline;">



<div id="google_translate_element" style="display: none;">
</div>

<div class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</div>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit" async></script>
</div>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">MySQL慢SQL探究</h1>
  <h2 class="post-subtitle">MySQL慢SQL探究</h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2024-09-25T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Sep 25, 2024
    </time>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 14 mins</span>
  </div>
<div class="post-tags"><a class="post-tag" href="/tags.html#MySQL">#MySQL</a></div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <p><img src="https://github.com/jeffreytse/jekyll-theme-yat/assets/9413601/2ed22d49-90b1-4f7e-8e8f-b77b21dee505" alt="banner"></p>

<h2 id="前言">前言</h2>

<p>我们在日常开发中，一定遇见过某些SQL执行较慢的情况，我们俗称“慢SQL”，如果你对系统的接口性能要求较高的话，一定不会放过这种SQL，肯定会想办法进行解决，那么，导致慢SQL出现的原因，究竟可能都有哪些呢？</p>

<p>这是一道经典的面试题，就此我们来研究一番，下面，我们就来好好看一下，原因可能出在哪里。</p>

<p>本篇我们将从如下几个方面进行讨论：</p>

<p>1、慢SQL捕获</p>

<p>2、执行计划分析</p>

<p>3、引擎参数配置分析</p>

<p>让我们就此开启本次慢SQL分析之旅，Let’s go！</p>

<blockquote>
  <p>ps: 本篇文章的讨论，主要基于MySQL8.0数据库，Oracle等其他数据库不在本篇讨论范围之列。</p>
</blockquote>

<h2 id="1慢sql捕获">1、慢SQL捕获</h2>

<p>追查应用服务的慢SQL，首先需要追踪哪些SQL可能是慢SQL，对于Java服务，很多数据库中间件提供了慢SQL的追踪能力，例如Alibaba Druid，会将服务运行过程中的慢SQL打印到日志文件，方便开发运维人员追查。</p>

<p>MySQL当然也提供了捕获慢查询的监控能力，记录在MySQL中执行时间超过指定时间的SQL语句。</p>

<p>默认情况下，MySQL 并没有开启慢日志，可以通过修改 <code class="language-plaintext highlighter-rouge">slow_query_log</code> 参数来打开慢日志。与慢日志相关的参数介绍如下：</p>

<ul>
  <li>
<strong>slow_query_log</strong>：是否启用慢查询日志，1表示开启，0表示关闭，默认为关闭。</li>
  <li>
<strong>slow_query_log_file</strong>：指定慢查询日志位置及名称，默认值为<code class="language-plaintext highlighter-rouge">host_name-slow.log</code>，可指定绝对路径。</li>
  <li>
<strong>long_query_time</strong>：慢查询执行时间阈值，超过此时间会记录，默认为10，取值范围0~31536000，单位为秒。</li>
  <li>
<strong>min_examined_row_limit</strong>：对于查询扫描行数小于此参数的SQL，将不会记录到慢查询日志中，默认为0，最大值(bit-64)为18446744073709551615。</li>
  <li>
<strong>log_output</strong>：慢查询日志输出目标，默认为FILE，即输出到文件，取值为TABLE、FILE、NONE。</li>
  <li>
<strong>log_timestamps</strong>：主要是控制 error log、slow log、genera log 日志文件中的显示时区，默认使用UTC时区，取值为UTC、SYSTEM，建议改为 SYSTEM 系统时区。</li>
  <li>
<strong>log_queries_not_using_indexes</strong>：是否记录所有未使用索引的查询语句，默认为OFF。</li>
  <li>
<strong>log_slow_admin_statements</strong>：慢速管理语句是否写入慢日志中，管理语句包含 <code class="language-plaintext highlighter-rouge">ALTER TABLE, ANALYZE TABLE, CHECK TABLE, CREATE INDEX, DROP INDEX, OPTIMIZE TABLE, REPAIR TABLE</code>，默认为 OFF 即不写入。</li>
</ul>

<p>一般情况下，我们只需开启慢日志记录，配置下阈值时间，其余参数可按默认配置。对于阈值时间，可灵活调整，比如说可以设置为 1s 或 3s 。</p>

<h3 id="慢查询追踪配置方式">慢查询追踪配置方式</h3>

<p>MySQL提供了两种配置慢查询参数的方式，提供给开发者使用，下面我们依次来看一下。</p>

<p>第一种，将慢查询参数配置写入 MySQL 配置文件，永久生效</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 慢查询日志相关配置，可根据实际情况修改</span>
vim /etc/my.cnf 
<span class="o">[</span>mysqld] 
slow_query_log <span class="o">=</span> 1
slow_query_log_file <span class="o">=</span> /var/log/mysql/sql-slow.log
long_query_time <span class="o">=</span> 1
log_timestamps <span class="o">=</span> SYSTEM
log_output <span class="o">=</span> FILE
</code></pre></div></div>

<p>第二种，MySQL Server 中临时开启慢查询功能，当 MySQL Server 重启时，配置修改则全部失效并恢复原状</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET GLOBAL slow_query_log <span class="o">=</span> <span class="s1">'ON'</span><span class="p">;</span>
SET GLOBAL slow_query_log_file <span class="o">=</span> <span class="s1">'/var/log/mysql/sql-slow.log'</span><span class="p">;</span>
SET GLOBAL log_queries_not_using_indexes <span class="o">=</span> <span class="s1">'ON'</span><span class="p">;</span>
SET SESSION long_query_time <span class="o">=</span> 1<span class="p">;</span>
SET SESSION min_examined_row_limit <span class="o">=</span> 100<span class="p">;</span>
</code></pre></div></div>

<p>下面我们具体看下，慢日志会记录哪些内容？我们执行一条较慢的查询 SQL ，来看下在慢日志中的体现。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Time: 2022-11-02T09:23:37.004885Z</span>
<span class="c"># User@Host: wtopps[wtopps] @ localhost []  Id: 10831</span>
<span class="c"># Query_time: 1.609214  Lock_time: 0.003828 Rows_sent: 2050008  Rows_examined: 2150010</span>
SET <span class="nv">timestamp</span><span class="o">=</span>1667381015<span class="p">;</span>
SELECT A.<span class="k">*</span> FROM <span class="sb">`</span>user<span class="sb">`</span> A LEFT JOIN grade B ON A.<span class="sb">`</span><span class="nb">id</span><span class="sb">`</span> <span class="o">=</span> B.<span class="sb">`</span>user_id<span class="sb">`</span><span class="p">;</span>
</code></pre></div></div>

<p>对于每一组慢SQL，日志内容格式如下：</p>

<p>第一行记录的是该条 SQL 执行的时刻（如果 log_timestamps 参数为 UTC ，则改时间会显示 UTC 时区时间）</p>

<p>第二行记录的是执行该语句的用户和 IP 以及链接 id</p>

<p>第三行的几个字段含义如下：</p>

<ul>
  <li>
<strong>Query_time</strong>：语句执行时间，以秒为单位。</li>
  <li>
<strong>Lock_time</strong>：获取锁的时间(以秒为单位)。</li>
  <li>
<strong>Rows_sent</strong>：发送给 Client 端的行数。</li>
  <li>
<strong>Rows_examined</strong>：服务器层检查的行数(不计算存储引擎内部的任何处理)</li>
</ul>

<p>通过慢查询日志，我们可以捕获到具体的慢SQL，接下来，则要具体分析慢SQL产生的可能原因。</p>

<h2 id="2情况分析">2、情况分析</h2>

<h3 id="为什么查询会慢">为什么查询会慢？</h3>

<p>在尝试编写快速的查询之前，需要清楚一点，真正重要是响应时间。如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。</p>

<p>MySQL在执行查询的时候有哪些子任务，哪些子任务运行的速度很慢？这里很难给出完整的列表，通常来说，查询的生命周期大致可以按照顺序来看：</p>

<p>从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。</p>

<p><img src="/assets/images/cd8a41908bfb440f839ff4af1b58e49d.png" alt="mysql执行过程"></p>

<p>在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。</p>

<p>根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。</p>

<p>在每一个消耗大量时间的查询案例中，大概率会出现一些不必要的额外操作、某些操作被额外地重复了很多次、某些操作执行得太慢等。优化查询的目的就是减少和消除这些操作所花费的时间。</p>

<p>再次申明一点，对于一个查询的全部生命周期，上面列的并不完整。这里我们只是想说明：了解查询的生命周期、清楚查询的时间消耗情况对于优化查询有很大的意义。有了这些概念，我们再一起来看看如何优化查询。</p>

<p>捕获具体的慢查询SQL后，我们需要对可能导致慢查询的原因进行分析，我们可以从如下几个角度，对问题进行拆解：</p>

<ul>
  <li>SQL执行计划分析</li>
  <li>引擎参数配置分析</li>
  <li>引擎参数配置分析（网络，物理机配置，内存，机器负载I/O）</li>
</ul>

<h2 id="21-sql执行计划分析">2.1 SQL执行计划分析</h2>

<p>查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免地需要筛选大量数据，但在实际业务场景中，这并不常见。</p>

<p>大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效：</p>

<p>1．确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。</p>

<p>2．确认MySQL服务器层是否在分析大量超过需要的数据行。</p>

<p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU 和内存资源。</p>

<p>因此，合理的使用索引的重要性就凸显出来，如果查询中的查询条件未命中索引字段，MySQL引擎则只能对全量的数据进行检索，再根据查询条件进行过滤，筛选出目标的数据集，这个过程是非常耗时且低效的。</p>

<p>接下来，我们将逐步对SQL执行的过程进行分析拆解，通过工具手段剖析慢查询的具体原因。</p>

<p><img src="/assets/images/b3f6e845c2494fd9bdcaa7141f2758d3.png" alt="SQL分析三步走"></p>

<h3 id="explain执行计划分析">explain执行计划分析</h3>

<p>对于SQL执行过程分析，最先登场的毫无疑问就是 <code class="language-plaintext highlighter-rouge">explain</code>语句了， <code class="language-plaintext highlighter-rouge">explain</code>是我们在日常开发最常使用的分析命令。其使用方式，这里不再赘述，一般来说，95% 的慢查询问题只需要 <code class="language-plaintext highlighter-rouge">explain</code> 就可以解决了。</p>

<p>对于<code class="language-plaintext highlighter-rouge">explain</code>执行计划的分析，我们需要关注最简单的衡量查询开销的两个点：</p>

<ul>
  <li>扫描的行数</li>
  <li>返回的行数</li>
</ul>

<p>通过<code class="language-plaintext highlighter-rouge">explain</code>执行计划可以获得SQL在执行时预估的扫描行数以及返回行数的大概比例，这在一定程度上能够说明该查询找到需要的数据的效率高不高。</p>

<p>但这个指标也并不是绝对的，因为并不是所有的行的访问代价都是相同的。较短的行的访问速度更快，内存中的行也比磁盘中的行的访问速度要，快得多。</p>

<p>理想情况下扫描的行数和返回的行数应该是相同的。但实际情况中这种情况并不多见。</p>

<p>例如在做一个多表的<code class="language-plaintext highlighter-rouge">join</code>关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1：1和10：1之间，不过有时候这个值也可能非常非常大。</p>

<p><b>比值越大则意味着查询效率越低，因为引擎执行扫描出的大部分数据行都会被丢弃，这也意味着需要执行更多的I/O操作，因此尽可能降低扫描的行数对返回的行数的比率，是我们对慢查询优化的关键所在。</b></p>

<p>一般MySQL 能够使用如下三种方式应用<code class="language-plaintext highlighter-rouge">where</code>条件，从好到坏依次为：</p>

<ul>
  <li>在索引中使用<code class="language-plaintext highlighter-rouge">where</code>条件来过滤不匹配的记录。这是在存储引擎层完成的。</li>
  <li>使用索引覆盖扫描（在<code class="language-plaintext highlighter-rouge">Extra</code>列中出现了<code class="language-plaintext highlighter-rouge">Using index</code>）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。</li>
  <li>从数据表中返回数据，然后过滤不满足条件的记录（在<code class="language-plaintext highlighter-rouge">Extra</code>列中出现<code class="language-plaintext highlighter-rouge">Using Where</code>）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。</li>
</ul>

<blockquote>
  <p>Extra中Using Index与Using Where，MySQL官方文档的解释如下：</p>

  <p>Using Index</p>

  <p>The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. This strategy can be used when the query uses only columns that are part of a single index.</p>

  <p>Using Where</p>

  <p>A <code class="language-plaintext highlighter-rouge">WHERE</code> clause is used to restrict which rows to match against the next table or send to the client. Unless you specifically intend to fetch or examine all rows from the table, you may have something wrong in your query if the <code class="language-plaintext highlighter-rouge">Extra</code> value is not <code class="language-plaintext highlighter-rouge">Using where</code> and the table join type is <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_all"><code class="language-plaintext highlighter-rouge">ALL</code></a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_index"><code class="language-plaintext highlighter-rouge">index</code></a>.</p>
</blockquote>

<p>使用<code class="language-plaintext highlighter-rouge">explain</code>判断导致查询慢的原因，判断依据可以根据如下几点：</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">where</code>查询条件中的字段，是否是索引字段，索引字段是否满足了最左匹配原则</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">where</code>查询条件中是否对索引字段使用了函数处理</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">对索引字段使用函数操作，会使得索引失效</code></li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">where</code>查询条件中是否存在<code class="language-plaintext highlighter-rouge">like %字段%</code> 情况</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">like %%的全模糊匹配，会使得索引失效，如需使用like，请使用like 字段%</code></li>
    </ul>
  </li>
  <li>
    <p>对于<code class="language-plaintext highlighter-rouge">select *</code>的查询，该表的字段数量为多少</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">对于巨型宽表，例如上百个字段的大表，select * 是效率低下的选择，实际业务中很少有情况会需要全部字段的情况，根据需要查询特定的字段是非常必要的</code></li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">where</code>查询条件中是否使用<code class="language-plaintext highlighter-rouge">or</code>，如果使用了，<code class="language-plaintext highlighter-rouge">or</code>的字段是否是主键或者索引字段</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">对于主键或索引字段，or与in不存在性能差距，对于非索引字段，or的性能会低于in</code></p>

        <div class="language-markdown highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>In many database servers, IN() is just a synonym for multiple OR clauses, 
because the two are logically equivalent. Not so in MySQL, 
which sorts the values in the IN() list and uses a fast binary search to see whether a value is in the list. 
This is O(Log n) in the size of the list, whereas an equivalent series of OR clauses is O(n) in the size of the list (i.e., much slower for large lists)
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>查询是否使用了多个表(大于3张) 的<code class="language-plaintext highlighter-rouge">join</code>操作，<code class="language-plaintext highlighter-rouge">join</code>表的数据量级如何，是否使用了索引字段进行查询</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">对于多表join的复杂联合查询，是可能产生慢SQL的重灾区，join子表的顺序决定了扫描结果集会有多大，需要结合explain进行分析判断</code></li>
      <li><code class="language-plaintext highlighter-rouge">实际业务场景中，也尽可能的避免多表join操作，需要在表设计阶段就做好冗余字段的考虑</code></li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">where</code>查询条件是否使用了分页查询，分页深度是多大</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">limit 10, offset 100000，MySQL在实际执行时，会查询出100010条记录，然后丢弃前100000条，性能会极为的糟糕</code></p>

        <p><code class="language-plaintext highlighter-rouge">对于深分页查询优化，当执行深度分页时，可以带入主键ID作为查询条件，执行下一页的查询时，将上一页最大的主键ID作为条件，id &gt; last_page_max_id</code></p>
      </li>
    </ul>
  </li>
</ul>

<p>综上我们总结，SQL执行时其扫描的行数决定了执行的效率，而决定扫描行数的关键，则是索引的命中情况与索引的质量。</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tips:关于索引的一些小建议

1、唯一索引命名uk字段，普通索引命名idx字段，过长时可用首字母替代

2、尽量避免三张表以上的join，对于多表join的情况，可以视情况考虑将一个大查询拆分成多个子查询，对结果集在业务层进行聚合处理。如必须要多表join的场景，特别注意多连表查询的扫描行数问题以及索引的命中情况。

3、varchar长字段建立索引，需要指定索引长度，根据文本区分度来决定长度。

4、避免左模糊，全模糊匹配。

5、order by 字段放在索引最后列，避免filesort

6、考虑利用覆盖索引来进行查询操作，避免回表

7、性能优化目标，需要为range级别以上，最好是ref级别，或者const最好。

8、区分度高的列在索引最左边。

9、避免字段类型不同造成的隐式转换，导致索引失效。例如：varchar和数字类型

10、根据大多数SQL来创建索引。

11、对于运行较久的大表，需要关注索引字段的区分度问题，当索引值出现了严重倾斜时，需要考虑优化拆分索引值。
</code></pre></div></div>

<h3 id="profile分析">PROFILE分析</h3>

<p>通过使用<code class="language-plaintext highlighter-rouge">explain</code>分析SQL的执行计划，我们可以看到SQL执行过程中是否使用索引，使用了哪些索引，索引扫描的行数等，但MySQL的慢查询，并不一定慢在有没有索引，SQL的执行环节中任意一环出了问题都会表现为查询变慢，所以即使执行过程命中了索引，<code class="language-plaintext highlighter-rouge">explain</code>的结果也很完美，但是还是慢，怎么办？</p>

<p>这时候，就需要<code class="language-plaintext highlighter-rouge">profile</code>工具来帮忙了，这个命令可以详细的列出 SQL 语句在每一个步骤消耗的时间，前提（缺点）是先执行一遍语句。</p>

<p>PROFILE 默认是关闭的，所以需要在<code class="language-plaintext highlighter-rouge">client</code>端先打开，操作如下：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">set</span> <span class="k">session</span> <span class="n">profiling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>在实际的生产环境中，可能会需要加大<code class="language-plaintext highlighter-rouge">profile</code>的队列，保证想要查看的 <code class="language-plaintext highlighter-rouge">profile</code>结果还保存着，因此可以用如下操作来增加<code class="language-plaintext highlighter-rouge">profile</code>的队列大小：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="k">session</span> <span class="n">profiling_history_size</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
</code></pre></div></div>

<p>让我们一起来看一下<code class="language-plaintext highlighter-rouge">profile</code>分析如何使用，我们先执行下面的SQL：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'小六'</span> <span class="k">and</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">300000003</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span> <span class="o">|</span> <span class="n">partitions</span> <span class="o">|</span> <span class="k">type</span> <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>  <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>    <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="k">user</span>  <span class="o">|</span> <span class="k">NULL</span>       <span class="o">|</span> <span class="k">ALL</span>  <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">2043040</span> <span class="o">|</span>     <span class="mi">1</span><span class="p">.</span><span class="mi">00</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></div>

<p>这个一个典型的效果较差的查询，<code class="language-plaintext highlighter-rouge">type=ALL</code>，没有命中索引，执行了全表扫描，我们使用<code class="language-plaintext highlighter-rouge">profile</code>分析一下各阶段的执行时间：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">profiles</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----------+------------+---------------------------------------------------------------+</span>
<span class="o">|</span> <span class="n">Query_ID</span> <span class="o">|</span> <span class="n">Duration</span>   <span class="o">|</span> <span class="n">Query</span>                                                         <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+------------+---------------------------------------------------------------+</span>
<span class="o">|</span>        <span class="mi">1</span> <span class="o">|</span> <span class="mi">0</span><span class="p">.</span><span class="mi">55695825</span> <span class="o">|</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'小六'</span> <span class="k">and</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">300000003</span>   <span class="o">|</span>
<span class="o">+</span><span class="c1">----------+------------+---------------------------------------------------------------+</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></div>

<p>找到我们需要分析的语句，查询执行耗时详情：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">profile</span> <span class="n">block</span> <span class="n">io</span><span class="p">,</span><span class="n">cpu</span><span class="p">,</span><span class="n">memory</span><span class="p">,</span><span class="k">source</span> <span class="k">for</span> <span class="n">query</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/assets/images/15dbb62df5fe4b958dce9d0f866d2f9e.png" alt="profile执行耗时详情"></p>

<p>从<code class="language-plaintext highlighter-rouge">profile</code>执行结果中，我们可以清晰的看到一条SQL在每个执行阶段的耗时、CPU使用率、IO等指标，帮助我们定位到慢查询具体执行耗时的阶段，对于该条SQL，执行过程中最耗时的部分是<code class="language-plaintext highlighter-rouge">executing</code>部分，<code class="language-plaintext highlighter-rouge">executing</code>阶段包括了执行线程正在为<code class="language-plaintext highlighter-rouge">SELECT</code>读取和处理数据行，并将数据发送到客户端。因为在这个状态下发生的操作往往执行大量的磁盘读取，所以它往往是在整个查询的生命周期中运行时间最长的一个阶段。</p>

<p>经过了对SQL语句进行<code class="language-plaintext highlighter-rouge">explain</code>与<code class="language-plaintext highlighter-rouge">profile</code>分析之后，一个 SQL 为什么慢，慢在哪里基本上可以定位出来了，那么最后的手段主要是解决什么问题呢？</p>

<p>我们将使用最终的分析工具，<code class="language-plaintext highlighter-rouge">OPTIMIZER_TRACE</code>。</p>

<h3 id="optimizer_trace分析">OPTIMIZER_TRACE分析</h3>

<p><code class="language-plaintext highlighter-rouge">OPTIMIZER_TRAC</code>E 是 MySQL 5.6 添加的新功能，这个功能可以看到内部查询计划的 <code class="language-plaintext highlighter-rouge">TRACE</code> 信息，也就是MySQL在执行过程中的具体决策细节，从而可以知道 MySQL 是如何在众多索引中的挑选最合适的索引。</p>

<p>如果我们通过执行计划，发现MySQL选择的索引并不符合我们的预期，就需要根据 <code class="language-plaintext highlighter-rouge">OPTIMIZER_TRACE</code> 的信息来判断为什么会选择它，是 MySQL 的配置原因，还是 SQL 某些地方写的不好导致 MySQL 误判。</p>

<p>开启这个功能的方式如下：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="k">session</span> <span class="n">optimizer_trace</span><span class="o">=</span><span class="s1">'enabled=on'</span><span class="p">;</span>
</code></pre></div></div>

<p>在客户端执行一个<code class="language-plaintext highlighter-rouge">EXPLAIN</code>语句，生成一个执行计划，然后在<code class="language-plaintext highlighter-rouge">information_chema.optimizer_trace</code>的表里面查找这一条语句对应的信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; <span class="k">select</span> <span class="k">*</span> from information_schema.optimizer_trace<span class="p">;</span>
| explain <span class="k">select</span> <span class="k">*</span> from user where age <span class="o">=</span> 21 | <span class="o">{</span>
  <span class="s2">"steps"</span>: <span class="o">[</span>
    <span class="o">{</span>
      <span class="s2">"join_preparation"</span>: <span class="o">{</span>
        <span class="s2">"select#"</span>: 1,
        <span class="s2">"steps"</span>: <span class="o">[</span>
          <span class="o">{</span>
            <span class="s2">"expanded_query"</span>: <span class="s2">"/* select#1 */ select </span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span><span class="nb">id</span><span class="sb">`</span><span class="s2"> AS </span><span class="sb">`</span><span class="nb">id</span><span class="sb">`</span><span class="s2">,</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>name<span class="sb">`</span><span class="s2"> AS </span><span class="sb">`</span>name<span class="sb">`</span><span class="s2">,</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>age<span class="sb">`</span><span class="s2"> AS </span><span class="sb">`</span>age<span class="sb">`</span><span class="s2">,</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>code<span class="sb">`</span><span class="s2"> AS </span><span class="sb">`</span>code<span class="sb">`</span><span class="s2"> from </span><span class="sb">`</span>user<span class="sb">`</span><span class="s2"> where (</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>age<span class="sb">`</span><span class="s2"> = 21)"</span>
          <span class="o">}</span>
        <span class="o">]</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"join_optimization"</span>: <span class="o">{</span>
        <span class="s2">"select#"</span>: 1,
        <span class="s2">"steps"</span>: <span class="o">[</span>
          <span class="o">{</span>
            <span class="s2">"condition_processing"</span>: <span class="o">{</span>
              <span class="s2">"condition"</span>: <span class="s2">"WHERE"</span>,
              <span class="s2">"original_condition"</span>: <span class="s2">"(</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>age<span class="sb">`</span><span class="s2"> = 21)"</span>,
              <span class="s2">"steps"</span>: <span class="o">[</span>
                <span class="o">{</span>
                  <span class="s2">"transformation"</span>: <span class="s2">"equality_propagation"</span>,
                  <span class="s2">"resulting_condition"</span>: <span class="s2">"multiple equal(21, </span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>age<span class="sb">`</span><span class="s2">)"</span>
                <span class="o">}</span>,
                <span class="o">{</span>
                  <span class="s2">"transformation"</span>: <span class="s2">"constant_propagation"</span>,
                  <span class="s2">"resulting_condition"</span>: <span class="s2">"multiple equal(21, </span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>age<span class="sb">`</span><span class="s2">)"</span>
                <span class="o">}</span>,
                <span class="o">{</span>
                  <span class="s2">"transformation"</span>: <span class="s2">"trivial_condition_removal"</span>,
                  <span class="s2">"resulting_condition"</span>: <span class="s2">"multiple equal(21, </span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>age<span class="sb">`</span><span class="s2">)"</span>
                <span class="o">}</span>
              <span class="o">]</span>
            <span class="o">}</span>
          <span class="o">}</span>,
          <span class="o">{</span>
            <span class="s2">"substitute_generated_columns"</span>: <span class="o">{</span>
            <span class="o">}</span>
          <span class="o">}</span>,
          <span class="o">{</span>
            <span class="s2">"table_dependencies"</span>: <span class="o">[</span>
              <span class="o">{</span>
                <span class="s2">"table"</span>: <span class="s2">"</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">"</span>,
                <span class="s2">"row_may_be_null"</span>: <span class="nb">false</span>,
                <span class="s2">"map_bit"</span>: 0,
                <span class="s2">"depends_on_map_bits"</span>: <span class="o">[</span>
                <span class="o">]</span>
              <span class="o">}</span>
            <span class="o">]</span>
          <span class="o">}</span>,
          <span class="o">{</span>
            <span class="s2">"ref_optimizer_key_uses"</span>: <span class="o">[</span>
              <span class="o">{</span>
                <span class="s2">"table"</span>: <span class="s2">"</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">"</span>,
                <span class="s2">"field"</span>: <span class="s2">"age"</span>,
                <span class="s2">"equals"</span>: <span class="s2">"21"</span>,
                <span class="s2">"null_rejecting"</span>: <span class="nb">true</span>
              <span class="o">}</span>
            <span class="o">]</span>
          <span class="o">}</span>,
          <span class="o">{</span>
            <span class="s2">"rows_estimation"</span>: <span class="o">[</span>
              <span class="o">{</span>
                <span class="s2">"table"</span>: <span class="s2">"</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">"</span>,
                <span class="s2">"range_analysis"</span>: <span class="o">{</span>
                  <span class="s2">"table_scan"</span>: <span class="o">{</span>
                    <span class="s2">"rows"</span>: 2043040,
                    <span class="s2">"cost"</span>: 205676
                  <span class="o">}</span>,
                  <span class="s2">"potential_range_indexes"</span>: <span class="o">[</span>
                    <span class="o">{</span>
                      <span class="s2">"index"</span>: <span class="s2">"PRIMARY"</span>,
                      <span class="s2">"usable"</span>: <span class="nb">false</span>,
                      <span class="s2">"cause"</span>: <span class="s2">"not_applicable"</span>
                    <span class="o">}</span>,
                    <span class="o">{</span>
                      <span class="s2">"index"</span>: <span class="s2">"idx_age"</span>,
                      <span class="s2">"usable"</span>: <span class="nb">true</span>,
                      <span class="s2">"key_parts"</span>: <span class="o">[</span>
                        <span class="s2">"age"</span>,
                        <span class="s2">"id"</span>
                      <span class="o">]</span>
                    <span class="o">}</span>
                  <span class="o">]</span>,
                  <span class="s2">"setup_range_conditions"</span>: <span class="o">[</span>
                  <span class="o">]</span>,
                  <span class="s2">"group_index_range"</span>: <span class="o">{</span>
                    <span class="s2">"chosen"</span>: <span class="nb">false</span>,
                    <span class="s2">"cause"</span>: <span class="s2">"not_group_by_or_distinct"</span>
                  <span class="o">}</span>,
                  <span class="s2">"skip_scan_range"</span>: <span class="o">{</span>
                    <span class="s2">"potential_skip_scan_indexes"</span>: <span class="o">[</span>
                      <span class="o">{</span>
                        <span class="s2">"index"</span>: <span class="s2">"idx_age"</span>,
                        <span class="s2">"usable"</span>: <span class="nb">false</span>,
                        <span class="s2">"cause"</span>: <span class="s2">"query_references_nonkey_column"</span>
                      <span class="o">}</span>
                    <span class="o">]</span>
                  <span class="o">}</span>,
                  <span class="s2">"analyzing_range_alternatives"</span>: <span class="o">{</span>
                    <span class="s2">"range_scan_alternatives"</span>: <span class="o">[</span>
                      <span class="o">{</span>
                        <span class="s2">"index"</span>: <span class="s2">"idx_age"</span>,
                        <span class="s2">"ranges"</span>: <span class="o">[</span>
                          <span class="s2">"21 &lt;= age &lt;= 21"</span>
                        <span class="o">]</span>,
                        <span class="s2">"index_dives_for_eq_ranges"</span>: <span class="nb">true</span>,
                        <span class="s2">"rowid_ordered"</span>: <span class="nb">true</span>,
                        <span class="s2">"using_mrr"</span>: <span class="nb">false</span>,
                        <span class="s2">"index_only"</span>: <span class="nb">false</span>,
                        <span class="s2">"in_memory"</span>: 0.788627,
                        <span class="s2">"rows"</span>: 1,
                        <span class="s2">"cost"</span>: 0.61,
                        <span class="s2">"chosen"</span>: <span class="nb">true</span>
                      <span class="o">}</span>
                    <span class="o">]</span>,
                    <span class="s2">"analyzing_roworder_intersect"</span>: <span class="o">{</span>
                      <span class="s2">"usable"</span>: <span class="nb">false</span>,
                      <span class="s2">"cause"</span>: <span class="s2">"too_few_roworder_scans"</span>
                    <span class="o">}</span>
                  <span class="o">}</span>,
                  <span class="s2">"chosen_range_access_summary"</span>: <span class="o">{</span>
                    <span class="s2">"range_access_plan"</span>: <span class="o">{</span>
                      <span class="s2">"type"</span>: <span class="s2">"range_scan"</span>,
                      <span class="s2">"index"</span>: <span class="s2">"idx_age"</span>,
                      <span class="s2">"rows"</span>: 1,
                      <span class="s2">"ranges"</span>: <span class="o">[</span>
                        <span class="s2">"21 &lt;= age &lt;= 21"</span>
                      <span class="o">]</span>
                    <span class="o">}</span>,
                    <span class="s2">"rows_for_plan"</span>: 1,
                    <span class="s2">"cost_for_plan"</span>: 0.61,
                    <span class="s2">"chosen"</span>: <span class="nb">true</span>
                  <span class="o">}</span>
                <span class="o">}</span>
              <span class="o">}</span>
            <span class="o">]</span>
          <span class="o">}</span>,
          <span class="o">{</span>
            <span class="s2">"considered_execution_plans"</span>: <span class="o">[</span>
              <span class="o">{</span>
                <span class="s2">"plan_prefix"</span>: <span class="o">[</span>
                <span class="o">]</span>,
                <span class="s2">"table"</span>: <span class="s2">"</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">"</span>,
                <span class="s2">"best_access_path"</span>: <span class="o">{</span>
                  <span class="s2">"considered_access_paths"</span>: <span class="o">[</span>
                    <span class="o">{</span>
                      <span class="s2">"access_type"</span>: <span class="s2">"ref"</span>,
                      <span class="s2">"index"</span>: <span class="s2">"idx_age"</span>,
                      <span class="s2">"rows"</span>: 1,
                      <span class="s2">"cost"</span>: 0.35,
                      <span class="s2">"chosen"</span>: <span class="nb">true</span>
                    <span class="o">}</span>,
                    <span class="o">{</span>
                      <span class="s2">"access_type"</span>: <span class="s2">"range"</span>,
                      <span class="s2">"range_details"</span>: <span class="o">{</span>
                        <span class="s2">"used_index"</span>: <span class="s2">"idx_age"</span>
                      <span class="o">}</span>,
                      <span class="s2">"chosen"</span>: <span class="nb">false</span>,
                      <span class="s2">"cause"</span>: <span class="s2">"heuristic_index_cheaper"</span>
                    <span class="o">}</span>
                  <span class="o">]</span>
                <span class="o">}</span>,
                <span class="s2">"condition_filtering_pct"</span>: 100,
                <span class="s2">"rows_for_plan"</span>: 1,
                <span class="s2">"cost_for_plan"</span>: 0.35,
                <span class="s2">"chosen"</span>: <span class="nb">true</span>
              <span class="o">}</span>
            <span class="o">]</span>
          <span class="o">}</span>,
          <span class="o">{</span>
            <span class="s2">"attaching_conditions_to_tables"</span>: <span class="o">{</span>
              <span class="s2">"original_condition"</span>: <span class="s2">"(</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>age<span class="sb">`</span><span class="s2"> = 21)"</span>,
              <span class="s2">"attached_conditions_computation"</span>: <span class="o">[</span>
              <span class="o">]</span>,
              <span class="s2">"attached_conditions_summary"</span>: <span class="o">[</span>
                <span class="o">{</span>
                  <span class="s2">"table"</span>: <span class="s2">"</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">"</span>,
                  <span class="s2">"attached"</span>: <span class="s2">"(</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>age<span class="sb">`</span><span class="s2"> = 21)"</span>
                <span class="o">}</span>
              <span class="o">]</span>
            <span class="o">}</span>
          <span class="o">}</span>,
          <span class="o">{</span>
            <span class="s2">"finalizing_table_conditions"</span>: <span class="o">[</span>
              <span class="o">{</span>
                <span class="s2">"table"</span>: <span class="s2">"</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">"</span>,
                <span class="s2">"original_table_condition"</span>: <span class="s2">"(</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">.</span><span class="sb">`</span>age<span class="sb">`</span><span class="s2"> = 21)"</span>,
                <span class="s2">"final_table_condition   "</span>: null
              <span class="o">}</span>
            <span class="o">]</span>
          <span class="o">}</span>,
          <span class="o">{</span>
            <span class="s2">"refine_plan"</span>: <span class="o">[</span>
              <span class="o">{</span>
                <span class="s2">"table"</span>: <span class="s2">"</span><span class="sb">`</span>user<span class="sb">`</span><span class="s2">"</span>
              <span class="o">}</span>
            <span class="o">]</span>
          <span class="o">}</span>
        <span class="o">]</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"join_explain"</span>: <span class="o">{</span>
        <span class="s2">"select#"</span>: 1,
        <span class="s2">"steps"</span>: <span class="o">[</span>
        <span class="o">]</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">]</span>
<span class="o">}</span>
1 row <span class="k">in </span><span class="nb">set</span> <span class="o">(</span>0.02 sec<span class="o">)</span>
</code></pre></div></div>

<p>内容是非常长的 JSON 格式，所以推荐把结果转存到其他地方，然后用 JSON 的转换工具来辅助查看，如果要看索引的选择情况，就重点关注这个 JSON 的<code class="language-plaintext highlighter-rouge">ref_optimizer_key_uses</code>，<code class="language-plaintext highlighter-rouge">rows_estimation</code> 及之后的部分，这里会展示索引选择相关的信息，截取一部分结果作为示例：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="nv">"ref_optimizer_key_uses"</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nv">"table"</span><span class="p">:</span> <span class="nv">"`user`"</span><span class="p">,</span>
            <span class="nv">"field"</span><span class="p">:</span> <span class="nv">"age"</span><span class="p">,</span>
            <span class="nv">"equals"</span><span class="p">:</span> <span class="nv">"21"</span><span class="p">,</span>
            <span class="nv">"null_rejecting"</span><span class="p">:</span> <span class="k">true</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
<span class="p">......</span>

<span class="nv">"chosen_range_access_summary"</span><span class="p">:</span> <span class="p">{</span>
    <span class="nv">"range_access_plan"</span><span class="p">:</span> <span class="p">{</span>
        <span class="nv">"type"</span><span class="p">:</span> <span class="nv">"range_scan"</span><span class="p">,</span>
        <span class="nv">"index"</span><span class="p">:</span> <span class="nv">"idx_age"</span><span class="p">,</span>
        <span class="nv">"rows"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nv">"ranges"</span><span class="p">:</span> <span class="p">[</span>
            <span class="nv">"21 &lt;= age &lt;= 21"</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="nv">"rows_for_plan"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nv">"cost_for_plan"</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">61</span><span class="p">,</span>
    <span class="nv">"chosen"</span><span class="p">:</span> <span class="k">true</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3引擎参数配置分析">3、引擎参数配置分析</h2>

<p>上面的篇幅中，我们针对SQL层面进行了可能导致慢查询的原因分析，MySQL的数据最终都会存储在磁盘上，因此操作系统的I/O情况也会影响MySQL的运行性能，这一章节我们将从底层入手，从操作系统I/O层面分析MySQL执行性能问题。</p>

<h3 id="io性能分析">I/O性能分析</h3>

<p>Linux系统查看系统I/O情况，可以使用<code class="language-plaintext highlighter-rouge">iostat</code>命令：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@VM-16-14-centos ~]# iostat <span class="nt">-x</span> 1 <span class="nt">-m</span>
Linux 3.10.0-1160.11.1.el7.x86_64 <span class="o">(</span>VM-16-14-centos<span class="o">)</span>     12/21/2022      _x86_64_        <span class="o">(</span>1 CPU<span class="o">)</span>

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.82    0.00    0.67    0.07    0.00   98.44

Device:         rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
vda               0.00     1.67    0.04    2.49     0.00     0.02    17.55     0.01    2.34    3.74    2.31   0.29   0.07
scd0              0.00     0.00    0.00    0.00     0.00     0.00     7.10     0.00    0.89    0.89    0.00   0.88   0.00
</code></pre></div></div>

<p>avg-cpu 自然就是 CPU 相关的指标，判断 IO 问题时可以关注 %iowait，其他指标的意义如下：</p>

<ul>
  <li>r/s 和 w/s：<strong>合并过后的</strong>读请求和写请求的每秒请求数，可以当做 IOPS 来理解。</li>
  <li>rMB/s 和 wMB/s：磁盘的读写吞吐量。</li>
  <li>rrqm/s 和 wrqm/s：每秒合并的读请求和写请求数量。</li>
  <li>r_await 和 w_await：读请求和写请求的平均响应时间，包含真正的处理时间和队列中的等待时间（ms）。</li>
  <li>avgrq-sz：平均每次设备I/O操作的数据大小 (扇区)。</li>
  <li>avgqu-sz：平均I/O队列长度。</li>
  <li>await：平均每次设备I/O操作的等待时间 (毫秒)。</li>
  <li>scvtm：计算出来的平均 IO 响应时间，目前已经不准确，不用再关注。</li>
  <li>%util：如果使用了 RAID 或者 SSD，则忽略这个指标，仅在单块机械盘上准确。</li>
</ul>

<p>一般来说，评价一块 IO 设备（忽略机械盘的情况，没有评价的意义）是否达到了高负载情况，可以看这几个指标：r/s，w/s，rMB/s，wMB/s，r_await，w_await，avgqu-sz。</p>

<h4 id="mysql-io参数">MySQL I/O参数</h4>

<p>MySQL 涉及到 IO 相关的参数会比较多，因此这里仅一部分经常用到的参数：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">参数</th>
      <th style="text-align: left">默认设置</th>
      <th style="text-align: left">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">innodb_io_capacity</td>
      <td style="text-align: left">200</td>
      <td style="text-align: left">定义了后台任务可用的 IOPS 量，InnoDB后台任务可用的每秒I/O操作数（IOPS），例如从缓冲池冲刷页面和从变更缓冲区合并数据。</td>
    </tr>
    <tr>
      <td style="text-align: left">innodb_io_capacity_max</td>
      <td style="text-align: left">动态</td>
      <td style="text-align: left">定义了后台任务可用的最大 IOPS 量</td>
    </tr>
    <tr>
      <td style="text-align: left">innodb_flush_log_at_trx_commit</td>
      <td style="text-align: left">1</td>
      <td style="text-align: left">控制事务的提交策略 <br>0：日志缓存区将每隔一秒写到日志文件中，并且将日志文件的数据刷新到磁盘上。该模式下在事务提交时不会主动触发写入磁盘的操作。 <br>1：每次事务提交时RDS for MySQL都会把日志缓存区的数据写入日志文件中，并且刷新到磁盘中，该模式为系统默认。 <br>2：每次事务提交时RDS for MySQL都会把日志缓存区的数据写入日志文件中，但是并不会同时刷新到磁盘上。该模式下，MySQL会每秒执行一次刷新磁盘操作。</td>
    </tr>
    <tr>
      <td style="text-align: left">sync_binlog</td>
      <td style="text-align: left">1</td>
      <td style="text-align: left">控制 binlog 落盘的频率<br><strong>0 ：</strong>存储引擎不进行binlog的刷新到磁盘，而由操作系统的文件系统控制缓存刷新。<br><strong>1：</strong>每提交一次事务，存储引擎调用文件系统的sync操作进行一次缓存的刷新，这种方式最安全，但性能较低。<br><strong>n：</strong>在每N次binlog日志文件写入后与磁盘同步，存储引擎调用文件系统的sync操作进行一次缓存的刷新。</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">innodb_io_capacity</code> 和 <code class="language-plaintext highlighter-rouge">innodb_io_capacity_max</code> 是最直接限制 <code class="language-plaintext highlighter-rouge">IOPS</code> 的指标，<strong>大多数时候</strong>，SSD 可以设置成 16000 或者更高的数值，如果是云主机或者其他的共享存储设备，则需要了解一下详细的 <code class="language-plaintext highlighter-rouge">IOPS</code> 上限再具体调整。</p>

<p><code class="language-plaintext highlighter-rouge">trx_commit</code> 和 <code class="language-plaintext highlighter-rouge">sync_binlog</code> 这两个参数也放进来的原因是不同的参数组合对 IO 的压力也会有区别。</p>

<p>通常的用法是<strong>双 1</strong> 或者 <strong>20（二零）</strong>，参考官方文档的描述，<strong>双 1</strong> 在每次提交事务的时候都会刷盘，对 IO 的压力要高不少；</p>

<p>20 则是滞后刷盘，对 IO 的压力会较小，因此写入 QPS 会高一些。</p>

<p>另外，可以关注到一个细节，<code class="language-plaintext highlighter-rouge">innodb_io_capacity</code> 的描述对象是：<strong>后台任务</strong>。这代表着 MySQL 后台的 flush，purge 操作会受到这个参数设置的限制。</p>

<p>吞吐量和 IOPS ，一般情况下衡量 IO 系统性能最直观的指标，并没有特别的提及，主要原因还是判断起来很简单：如果<code class="language-plaintext highlighter-rouge">iostat</code>的指标已经<strong>达到或者接近了实际硬件的指标（比如达到了 75%）</strong>，那么根据业务量增长的情况及早规划硬件升级或者<strong>其他的手段</strong>来分散读写压力。</p>

<p>常规的手段，可以简单的遵循以下场景来酌情使用：<strong>读多写少读写分离，写多读少拆库拆表加缓存</strong>。</p>

<h2 id="其他原因分析">其他原因分析</h2>

<h3 id="网络抖动">网络抖动</h3>

<p>目前的互联网应用服务，数据库的部署与应用服务的部署，不会在一台服务器上，那么应用服务器与数据库服务器之间就需要通过网络通信，一般情况来讲，都会在同机房或同一个可用区进行部署，以保证网络通信的质量。</p>

<p>但是难免可能会出现网络抖动的情况，这种情况下，对应用服务来讲，可能会出现一条SQL执行较慢的情况，但不是由于数据库原因导致的，而是由于网络原因导致的。</p>

<p>发现偶现的SQL执行慢，且SQL本身执行计划没有问题，可以从网络的角度分析问题，在服务所在的机器ping数据库服务器，查看响应时间，特别针对数据库服务器与业务服务器跨城市的情况，如果没有拉通专线访问，会很容易出现网络慢导致的问题。</p>

<h3 id="单表数据量过大">单表数据量过大</h3>

<p>上面我们提到了InnoDB的数据存储方式是<b>面向主键索引进行数据存储的。</b> InnoDB的数据表数量级超过几千万后，性能会出现下降，核心是由于B+Tree的数据结构导致的。</p>

<p>因此，当你的数据表超过几千万量级的时候，SQL执行即使全部命中的索引，也有可能出现执行慢的情况。</p>

<p>这个时候，建议考虑采用拆表。目前开源的优秀的分库分表中间件有很多，例如<code class="language-plaintext highlighter-rouge">sharing-JDBC</code>、<code class="language-plaintext highlighter-rouge">MyCat</code>等，可以根据业务的实际情况进行选择，这里就不过多的进行赘述。</p>

<h2 id="总结">总结</h2>

<p>本篇，我们围绕着一个问题：<code class="language-plaintext highlighter-rouge">一条SQL执行较慢可能有哪些原因导致的？</code> 进行了研究，总结一下，大部分的慢查询其实均由SQL书写不当导致的，通过explain命令结合实际业务场景分析，可以解决绝大多数的慢查询问题，对于一些疑难杂症SQL，使用MySQL强大的SQL分析工具，也可以找出真正的问题原因。</p>

<p>另外，系统层面的分析也是必不可少的，作为开发人员，我们也需要掌握一些DBA的分析手段，检查MySQL运行性能情况，保证数据库服务的稳定运行。</p>

<p>本篇参考：</p>

<p>MySQL官方文档The Slow Query Log：</p>

<p>https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html</p>

<p>https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_long_query_time</p>

<p>https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information</p>

<p>mysql or/in性能对比：</p>

<p>https://www.cnblogs.com/chihirotan/p/7457204.html</p>

<p>MySQL explain结果Extra中”Using Index”与”Using where; Using index”区别探究：</p>

<p>https://www.cnblogs.com/AcAc-t/p/mysql_explain_difference_between_using_index_and_using_where.html</p>

<p>MySQL General Thread States：</p>

<p>https://dev.mysql.com/doc/refman/8.0/en/general-thread-states.html</p>

<p>innodb_flush_log_at_trx_commit和sync_binlog参数详解：</p>

<p>https://support.huaweicloud.com/bestpractice-rds/rds_02_0010.html</p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/mysql/2024/09/25/MySQL%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E6%9C%89%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F.html" title="MySQL主键自增有几种模式？">MySQL主键自增有几种模式？</a><a class="next" href="/redis/2024/09/25/Redis-key%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E6%9C%BA%E5%88%B6.html" title="Redis key过期删除机制">Redis key过期删除机制</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li class="top-post">
          <a class="post-link" href="/mysql/2024/09/25/MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86redolog%E8%BF%98%E9%9C%80%E8%A6%81double-write-buffer.html" title="MySQL为什么有了redolog还需要double write buffer">
            MySQL为什么有了redolog还需要double write buffer<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="top-post">
          <a class="post-link" href="/redis/2024/09/25/Redis6.0-Client-Side%E7%BC%93%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88.html" title="Redis6.0 Client-Side缓存是什么">
            Redis6.0 Client-Side缓存是什么<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="top-post">
          <a class="post-link" href="/java/2024/09/25/Java-ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0.html" title="Java ThreadPoolExecutor线程池概述">
            Java ThreadPoolExecutor线程池概述<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="top-post">
          <a class="post-link" href="/redis/2024/09/25/Redis-key%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E6%9C%BA%E5%88%B6.html" title="Redis key过期删除机制">
            Redis key过期删除机制<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Unpublished Work <span class="copyleft">©</span> 2017-2024 GitHub User</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
